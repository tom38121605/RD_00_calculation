C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SNOOZ
OBJECT MODULE PLACED IN .\Objects\SNOOZ.obj
COMPILER INVOKED BY: C:\Keil_c51\C51\BIN\C51.EXE SNOOZ.c LARGE OPTIMIZE(3,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FOS
                    -C_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\SNOOZ.lst) TABS(3) OBJECT(.\Objects\SNOOZ.obj)

line level    source

   1          
   2          #include "N76E003.h"
   3          #include "Common.h"
   4          #include "Delay.h"
   5          #include "SFR_Macro.h"
   6          #include "Function_define.h"
   7          
   8          
   9          #define SNOOZGO     
  10          //#define SNOOZBABY   
  11          //#define SNOOZBUTTON
  12          
  13          
  14          volatile UINT8 flg_stopsendpair =0;
  15          volatile UINT8 flg_switchaux =0;
  16          
  17          volatile UINT8 flg_pairing =0; 
  18          volatile UINT16 ipairingcount =0;
  19          
  20          
  21          UINT8 flg_reset =0;
  22          UINT8 flg_standby =0;
  23          
  24          
  25          //dataflash
  26          #define   FIRSTCONFIGREG       0x4400
  27          #define   VOICEMODEREG         0x4401
  28          #define   BTVOLREG             0x4402
  29          #define   NOISEVOLREG          0x4403
  30          #define   NOISEMODEREG         0x4404
  31          
  32          
  33          //i2c
  34          
  35          #define   FIRSTI2CREG       0x01
  36          
  37          #define I2C_CLOCK_50KHz     79 
  38          #define I2C_CLOCK_100KHz    39 
  39          #define I2C_CLOCK_200KHz    19 
  40          #define I2C_CLOCK_400KHz    9 
  41          
  42          #define SLAVEADDR_SLA       0xA0 
  43          #define SLAVEADDR_WR        0
  44          #define SLAVEADDR_RD        1
  45          
  46          bit I2C_Reset_Flag;
  47          
  48          
  49          //white noise
  50          
  51          //#define NOISEBASEVOLTOP    13
  52          #define NOISEBASEVOLTOP    2
  53          
  54          
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 2   

  55          #define NOISEBASEVOLSTART  10
  56          
  57          
  58          
  59          //UINT8 flg_newnoise = 0; 
  60          UINT8 inoisevolume =0;
  61          UINT8 inoisevolume_top = 0;
  62          
  63          UINT8 inoisebasevol =0;
  64          //UINT8 inoisebasevol_back =0;
  65          
  66          #define BTVOLTOP    26
  67          #define BTVOLSTART  8
  68          
  69          UINT8 ibtvol =0;
  70          //UINT8 ibtvol_back =0;
  71          
  72          
  73          //key 
  74          
  75          UINT8   KEY0_NC_NULL  =0; 
  76          
  77          //#define LONGKEYCOUNT2_PWM0     75     //3.6s
  78          //#define LONGKEYCOUNT2_PWM1_6     150    //3.6s
  79          //#define LONGKEYCOUNT2_NOPWM      180    //3.6s
  80          
  81          //UINT32 LONGKEYCOUNT2 = 150;    //fixed 3.0s+ 
  82          
  83          //UINT32 LONGKEYCOUNT2 = 90;    
  84          UINT32 LONGKEYCOUNT2 = 180;    
  85          
  86          
  87          UINT8 flg_keydown1 =0;
  88          UINT8 flg_keydown2 =0;
  89          UINT8 flg_keydown3 =0;
  90          UINT8 flg_keydown4 =0;
  91          UINT8 flg_keydown12 =0;
  92          UINT8 flg_keydown20 =0;
  93          
  94          
  95          UINT8 ikeyvalue1 =0;
  96          UINT8 ikeyvalue2 =0;
  97          UINT8 ikeyvalue3 =0;
  98          UINT8 ikeyvalue4 =0;
  99          UINT8 ikeyvalue12 =0;
 100          
 101          UINT32 ikeynum1 =0;
 102          UINT32 ikeynum2 =0;
 103          UINT32 ikeynum3 =0;
 104          UINT32 ikeynum4 =0;
 105          UINT32 ikeynum12 =0;
 106          
 107          UINT8 flg_keycome1 =0;
 108          UINT8 flg_keycome2 =0;
 109          UINT8 flg_keycome3 =0;
 110          UINT8 flg_keycome4 =0;
 111          UINT8 flg_keycome12 =0;
 112          
 113           
 114          UINT8 flg_keydown10 =0;
 115          UINT8 ikeyvalue10 =0;
 116          UINT8 flg_power =0;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 3   

 117          
 118          UINT32 ikeynum10=0;
 119          UINT8 flg_keycome10 =0;
 120          
 121          UINT8 ikeytouch1 =0;
 122          UINT8 ikeytouch2 =0;
 123          
 124          
 125          //---------V1.2-----------
 126          
 127          //#define ADC_VOL_GAP                   200   
 128          
 129          //#define ADC_VOLDEC                    (1200 - ADC_VOL_GAP)
 130          //#define ADC_VOLADD                    (1750 - ADC_VOL_GAP)   
 131          //#define ADC_TONE                      (2075 - ADC_VOL_GAP)   //建议改成1k电阻，这里为2242  -> 2250
 132          
 133          //#define ADC_VOL_NC                  300   //(ADC_VOLDEC  - ADC_VOL_GAP)  
 134          // 
 135          //#define ADC_VOL_NC2                 2300  //(ADC_TONE + ADC_VOL_GAP)    
 136          
 137          
 138          //---------V1.4-----------
 139          
 140          #define ADC_VOL_GAP                   200   //150
 141          
 142          //#define ADC_VOLBOTH                   (870 - ADC_VOL_GAP)
 143          #define ADC_VOLBOTH                   (871 - ADC_VOL_GAP)
 144          
 145          //#define ADC_VOLDEC                    (1200 - ADC_VOL_GAP)
 146          #define ADC_VOLDEC                    (1184 - ADC_VOL_GAP)
 147          
 148          #define ADC_VOLADD                    (1650 - ADC_VOL_GAP)   
 149          #define ADC_TONE                      (2200 - ADC_VOL_GAP)   
 150          
 151          //#define ADC_VOLBOTH2                   (870 + ADC_VOL_GAP)
 152          #define ADC_VOLBOTH2                   (871 + ADC_VOL_GAP)
 153          
 154          
 155          //#define ADC_VOLDEC2                    (1200 + ADC_VOL_GAP)
 156          #define ADC_VOLDEC2                    (1184 + ADC_VOL_GAP)
 157          
 158          #define ADC_VOLADD2                    (1650 + ADC_VOL_GAP)   
 159          #define ADC_TONE2                      (2200 + ADC_VOL_GAP)  
 160          
 161          
 162          #define ADC_BLUETOOTH                    (2626 - ADC_VOL_GAP)   //SNOOZ BUTTON
 163          #define ADC_BLUETOOTH2                   (2626 + ADC_VOL_GAP)   //SNOOZ BUTTON
 164          
 165          
 166          #define ADC_VOL_NC                  300   //(ADC_VOLDEC  - ADC_VOL_GAP)  
 167          #define ADC_VOL_NC2                 (2200 + ADC_VOL_GAP)    //(ADC_BLUETOOTH + ADC_VOL_GAP)  
 168          
 169          
 170          //pwm
 171          
 172          UINT8  flg_openpwm =0;
 173          //UINT32 ipwmcount = 0;
 174          UINT8 ipwm_mode=0;
 175          
 176          
 177          //#define TIMER1_RELOAD_VALUE     84
 178          //#define PWM_PERIOD    0x1ff
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 4   

 179          
 180          
 181          static S16 Harm_Val = 0x00;      // State for harmonic generator
 182          static UINT16 LFSR = 0xff;       // Any non-zero value will work as the seed
 183          static S16 LPF, L_OUT, S_OUT, LSB = 0x100;
 184          static U8   CTR_DIR = 0; 
 185          //static U8   FN_MODE = 1;
 186          static U8   WN_MODE = 1;
 187          
 188          
 189          //static U8 LPF_K = 5;
 190          //static U8 HARM_K = 7;
 191          //static U8 NOISE_K = 7;
 192          //static U8 INCR = 16;
 193          
 194          
 195          static U8 LPF_K = 5;
 196          static U8 HARM_K = 7;
 197          static U8 NOISE_K = 1;
 198          static U8 INCR = 0;
 199          
 200          
 201          
 202          //BT command 
 203          
 204          UINT8 spoweron[5]  = {0xA5, 0x03, 0x84, 0x01, 0x2d};
 205          UINT8 spoweron2[5]  = {0xA5, 0x03, 0x84, 0x05, 0x31};  //add
 206          
 207          UINT8 spoweroff[5] = {0xA5, 0x03, 0x84, 0x03, 0x2f};
 208          UINT8 spoweroff2[5] = {0xA5, 0x03, 0x8c, 0x01, 0x35};  //add
 209          
 210          UINT8 splaypause[5] = {0xA5, 0x03, 0x82, 0x03, 0x2d};
 211          UINT8 svoladd[5]    = {0xA5, 0x03, 0x8b, 0x20, 0x53};
 212          UINT8 svoldec[5]    = {0xA5, 0x03, 0x8b, 0x21, 0x54};
 213          
 214          UINT8 spairing[6] =   {0xA5, 0x04, 0x82, 0x07, 0x01, 0x33}; 
 215          UINT8 sBTAUX_Switch[5] = {0xA5, 0x03, 0x8c, 0x20, 0x54};
 216          
 217          UINT8 sreset[5] = {0xA5, 0x03, 0x82, 0x08, 0x32};    //reset, clear hisory device
 218          
 219          UINT8 seqcmd0[5] = {0xA5, 0x03, 0x8a, 0x00, 0x32};   //BT
 220          
 221          UINT8 seqcmd1[5] = {0xA5, 0x03, 0x8a, 0x04, 0x36};   //WN1
 222          UINT8 seqcmd2[5] = {0xA5, 0x03, 0x8a, 0x05, 0x37};   //WN2
 223          UINT8 seqcmd3[5] = {0xA5, 0x03, 0x8a, 0x06, 0x38};   //WN3
 224          
 225          UINT8 seqcmd4[5] = {0xA5, 0x03, 0x8a, 0x01, 0x33};   //FN1
 226          UINT8 seqcmd5[5] = {0xA5, 0x03, 0x8a, 0x02, 0x34};   //FN2
 227          UINT8 seqcmd6[5] = {0xA5, 0x03, 0x8a, 0x03, 0x35};   //FN3
 228          
 229          UINT8 spairingvoice[5] = {0xA5, 0x03, 0x8d, 0x21, 0x56};   //pairing voice  2.7S
 230          UINT8 sswitchvoice[5]  = {0xA5, 0x03, 0x8d, 0x22, 0x57};   //switch voice   0.5S
 231          
 232          
 233          //UINT8 svoicemode[5]={ };
 234          UINT8 flg_voicemode =0;     //0 -- BT, 1 -- AUX
 235          
 236          
 237          //timer1
 238          
 239          UINT32 itimer1_count1=0;
 240          UINT32 itimer1_count2=0;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 5   

 241          
 242          
 243          //adc
 244          
 245          UINT16 BAND_value=0;
 246          
 247          #define BAND_3300  1526  
 248          
 249          #define RESISTOR_UP_K     10
 250          #define RESISTOR_DOWN_K   15
 251           
 252          UINT16 iadcvalue=0;  
 253          UINT16 iadcvalue_out=0; 
 254          UINT16 iadcvalue_avr=0; 
 255          UINT16 iadcvalue_delay=0; 
 256          UINT8 iadccount=0;
 257          UINT8 flg_channel =0;
 258          UINT8 sadctemp1[20];
 259          UINT8 sadctemp2[20];
 260          UINT8 sadcstate[20];
 261          
 262          //double fadc_key=0;
 263          UINT16 iadc_key=0;
 264          
 265          
 266          
 267          void Switch_Delay1ms( UINT32 inum)
 268          {
 269   1         UINT32 itemp =0;
 270   1         
 271   1         if(flg_openpwm==0)
 272   1         {
 273   2            
 274   2            //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 275   2            
 276   2            itemp=inum;      
 277   2            Timer0_Delay1ms(itemp);
 278   2         }
 279   1         else
 280   1         {
 281   2            //LONGKEYCOUNT2 = LONGKEYCOUNT2_PWM;
 282   2            
 283   2            itemp=inum;      
 284   2            Timer0_Delay1ms(itemp);
 285   2         }
 286   1         
 287   1      }
 288          
 289          
 290          void count_Delay_ms(UINT32 ms)  //16M
 291          {
 292   1         UINT32 j;
 293   1         
 294   1         while(ms--)
 295   1         {
 296   2            
 297   2            //for(j = 0; j<173; j++)   
 298   2            for(j = 0; j<76; j++)   
 299   2            {
 300   3               _nop_();
 301   3               _nop_();
 302   3               _nop_();
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 6   

 303   3               _nop_();
 304   3            }
 305   2         }
 306   1         
 307   1      }
 308          
 309          #define UART_LOG 
 310          void iputs0(UINT8 *msg)
 311          {
 312   1         #ifdef UART_LOG   
 313   1         while(*msg)
 314   1             Send_Data_To_UART0(*msg++);
 315   1         
 316   1         #endif
 317   1      }
 318          
 319          void iputs0B(UINT8 *msg)
 320          {
 321   1         while(*msg)
 322   1             Send_Data_To_UART0(*msg++);
 323   1      }
 324          
 325          
 326          void iputbytes0(UINT8 *msg, UINT32 ilen)
 327          {
 328   1         while(ilen--)
 329   1             Send_Data_To_UART0(*msg++);
 330   1      }
 331          
 332          #define     CFG_READ            0xC0
 333          #define     CFG_ERASE           0xE2
 334          #define     CFG_BYTE_PROGRAM    0xE1 
 335          void Enable_WDT_Reset_Config(void)
 336          {
 337   1         set_IAPEN;
 338   1         set_CFUEN;
 339   1         
 340   1         IAPAL = 0x04;
 341   1         IAPAH = 0x00;
 342   1         IAPFD = 0x0F;
 343   1         IAPCN = CFG_BYTE_PROGRAM;
 344   1         set_IAPGO;  
 345   1         
 346   1         //trigger IAP
 347   1         while((CHPCON&SET_BIT6)==SET_BIT6);          //check IAPFF (CHPCON.6)
 348   1         
 349   1         clr_CFUEN;
 350   1         clr_IAPEN;
 351   1            
 352   1      }
 353          
 354          double  Bandgap_Voltage;
 355          void READ_BANDGAP(void)
 356          {
 357   1            UINT8 BandgapHigh,BandgapLow,BandgapMark;
 358   1            double Bandgap_Value,Bandgap_Voltage_Temp;
 359   1      
 360   1            set_IAPEN;
 361   1            IAPCN = READ_UID;
 362   1            IAPAL = 0x0d;
 363   1            IAPAH = 0x00;
 364   1            set_IAPGO;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 7   

 365   1            BandgapLow = IAPFD;
 366   1            BandgapMark = BandgapLow&0xF0;
 367   1               
 368   1            if (BandgapMark==0x80)
 369   1            {
 370   2                  BandgapLow = BandgapLow&0x0F;
 371   2                  IAPAL = 0x0C;
 372   2                  IAPAH = 0x00;
 373   2                  set_IAPGO;
 374   2                  BandgapHigh = IAPFD;
 375   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 376   2                  Bandgap_Voltage_Temp = Bandgap_Value*3/4;
 377   2                  Bandgap_Voltage = Bandgap_Voltage_Temp - 33;       //the actually banggap voltage value is similar this va
             -lue.
 378   2            }
 379   1            if (BandgapMark==0x00)
 380   1            {
 381   2                  BandgapLow = BandgapLow&0x0F;
 382   2                  IAPAL = 0x0C;
 383   2                  IAPAH = 0x00;
 384   2                  set_IAPGO;
 385   2                  BandgapHigh = IAPFD;
 386   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 387   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 388   2            }
 389   1            if (BandgapMark==0x90)
 390   1            {
 391   2                  IAPAL = 0x0E;
 392   2                  IAPAH = 0x00;
 393   2                  set_IAPGO;
 394   2                  BandgapHigh = IAPFD;
 395   2                  IAPAL = 0x0F;
 396   2                  IAPAH = 0x00;
 397   2                  set_IAPGO;
 398   2                  BandgapLow = IAPFD;
 399   2                  BandgapLow = BandgapLow&0x0F;
 400   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 401   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 402   2            }
 403   1            clr_IAPEN;
 404   1            
 405   1      //       printf ("\n BG High = %bX",BandgapHigh); 
 406   1      //       printf ("\n BG Low = %bX",BandgapLow); 
 407   1      //       printf ("\n BG ROMMAP = %e",Bandgap_Voltage); 
 408   1            
 409   1      }
 410          
 411          
 412          
 413          //-------------------------------------------------------------------------
 414          #define     CID_READ            0x0B
 415          #define     DID_READ            0x0C
 416          
 417          #define     PAGE_ERASE_AP       0x22
 418          #define     BYTE_READ_AP        0x00
 419          #define     BYTE_PROGRAM_AP     0x21
 420          #define     PAGE_SIZE           128u
 421          
 422          #define     ERASE_FAIL          0x70
 423          #define     PROGRAM_FAIL        0x71
 424          #define     IAPFF_FAIL          0x72
 425          #define     IAP_PASS            0x00
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 8   

 426          
 427          static bit EA_Save_bit;
 428          
 429          void Enable_IAP_Mode(void)
 430          {
 431   1         EA_Save_bit=EA;
 432   1         EA=0;
 433   1         TA=0xAA;
 434   1         TA=0x55;
 435   1         CHPCON|=0x01 ;
 436   1         TA=0xAA;
 437   1         TA=0x55;
 438   1         IAPUEN|=0x01;
 439   1         EA=EA_Save_bit;
 440   1      }
 441          
 442          void Disable_IAP_Mode(void)
 443          {
 444   1        EA_Save_bit=EA;
 445   1        EA=0;
 446   1        TA=0xAA;
 447   1        TA=0x55;
 448   1        IAPUEN&=~0x01;
 449   1        TA=0xAA;
 450   1        TA=0x55;
 451   1        CHPCON&=~0x01;
 452   1        EA=EA_Save_bit;
 453   1      }
 454           
 455          void Trigger_IAP(void)
 456          {
 457   1         EA_Save_bit=EA;
 458   1         EA=0;
 459   1         TA=0xAA;
 460   1         TA=0x55;
 461   1         IAPTRG|=0x01;
 462   1         EA=EA_Save_bit;
 463   1      }
 464          
 465          uint8_t WriteDataToOnePage(uint16_t u16_addr,const uint8_t *pDat,uint8_t num)
 466          {
 467   1        uint8_t i,offset;
 468   1        uint8_t code *pCode;
 469   1        uint8_t xdata xd_tmp[128];
 470   1      
 471   1         Enable_IAP_Mode(); 
 472   1         offset=u16_addr&0x007F;
 473   1         i = PAGE_SIZE - offset;
 474   1         if(num>i)num=i;
 475   1        pCode = (uint8_t code *)u16_addr;
 476   1        for(i=0;i<num;i++)
 477   1        {
 478   2          if(pCode[i]!=0xFF)break;
 479   2        }
 480   1         if(i==num)
 481   1         {
 482   2           IAPCN =BYTE_PROGRAM_AP;
 483   2            IAPAL = u16_addr;
 484   2            IAPAH = u16_addr>>8;
 485   2            for(i=0;i<num;i++)
 486   2            {
 487   3               IAPFD = pDat[i];
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 9   

 488   3               Trigger_IAP();
 489   3               IAPAL++;
 490   3            }
 491   2            for(i=0;i<num;i++)
 492   2            {
 493   3               if(pCode[i]!=pDat[i])break;
 494   3            }
 495   2            if(i!=num) goto WriteDataToPage20;
 496   2         }
 497   1         else
 498   1         {
 499   2            WriteDataToPage20:
 500   2            pCode = (uint8_t code *)(u16_addr&0xff80);
 501   2            for(i=0;i<128;i++)
 502   2            {
 503   3               xd_tmp[i] = pCode[i];
 504   3            }
 505   2            for(i=0;i<num;i++)
 506   2            {
 507   3               xd_tmp[offset+i] = pDat[i];
 508   3            }
 509   2            do
 510   2            {
 511   3               IAPAL = (u16_addr&0xff80);
 512   3               IAPAH = u16_addr>>8;
 513   3               IAPCN = PAGE_ERASE_AP;
 514   3               IAPFD = 0xFF;  
 515   3               Trigger_IAP(); 
 516   3               IAPCN =BYTE_PROGRAM_AP;
 517   3               for(i=0;i<128;i++)
 518   3               {
 519   4                  IAPFD = xd_tmp[i];
 520   4                  Trigger_IAP();
 521   4                  IAPAL++;
 522   4               }
 523   3               for(i=0;i<128;i++)
 524   3               {
 525   4                  if(pCode[i]!=xd_tmp[i])break;
 526   4               }
 527   3            }while(i!=128);
 528   2            
 529   2         }
 530   1         Disable_IAP_Mode();
 531   1         
 532   1         return num;
 533   1      }  
 534          
 535          
 536          void WriteDataFlash(uint16_t u16_addr,uint8_t *pDat,uint16_t num)
 537          {
 538   1         uint8_t CPageAddr,EPageAddr,cnt;
 539   1         CPageAddr=u16_addr>>7;
 540   1         EPageAddr=(u16_addr+num)>>7;
 541   1         while(CPageAddr!=EPageAddr)
 542   1         {
 543   2            cnt=WriteDataToOnePage(u16_addr,pDat,128);
 544   2            u16_addr+=cnt;
 545   2            pDat+=cnt;
 546   2            num-=cnt;
 547   2            CPageAddr=u16_addr>>7;
 548   2         }
 549   1         if(num)
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 10  

 550   1         {
 551   2            WriteDataToOnePage(u16_addr,pDat,num);
 552   2         }
 553   1      }
 554          
 555          void ReadDataFlash(UINT8 code *iaddr,uint8_t *pDat,uint16_t num)
 556          {
 557   1         uint16_t i;
 558   1         
 559   1         for(i=0;i<num;i++)
 560   1            pDat[i] = *(iaddr+i);
 561   1      }
 562          
 563          
 564          void Init_I2C(void)
 565          {
 566   1         P13_OpenDrain_Mode;            
 567   1         P14_OpenDrain_Mode;  
 568   1         
 569   1         clr_I2CEN; 
 570   1      
 571   1         clr_I2CPX;   
 572   1      
 573   1         // Set I2C clock rate  
 574   1         I2CLK =  I2C_CLOCK_100KHz;    
 575   1      
 576   1         // Enable I2C  
 577   1         set_I2CEN;   
 578   1         
 579   1      }
 580          
 581          
 582          void I2C_SI_Check(void)
 583          {
 584   1         if (I2STAT == 0x00)
 585   1         {
 586   2            I2C_Reset_Flag = 1;
 587   2            set_STO;
 588   2            SI = 0;
 589   2            if(SI)
 590   2            {
 591   3               clr_I2CEN;
 592   3               set_I2CEN;
 593   3               clr_SI;
 594   3               clr_I2CEN;     
 595   3            }  
 596   2         }  
 597   1         
 598   1      }
 599          
 600          
 601          void i2c_write( UINT8 iaddr, UINT8 *sbuf, UINT8 ilen )
 602          {
 603   1         
 604   1          UINT8  u8Count;
 605   1         
 606   1          /* Step1 */
 607   1          set_STA;                                /* Send Start bit to I2C EEPROM */         
 608   1          clr_SI;
 609   1          while (!SI);
 610   1         
 611   1          if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 11  

 612   1          {
 613   2              I2C_Reset_Flag = 1;
 614   2              //iputs0("WR Send STAw' error\r\n");
 615   2              iputs0("write\r\n");
 616   2              goto Write_Error_Stop;
 617   2          }
 618   1          
 619   1          clr_STA; 
 620   1      
 621   1      
 622   1          /* Step2 */
 623   1          //--clr_STA;                                /* Clear STA and Keep SI value in I2CON */
 624   1          I2DAT = SLAVEADDR_SLA | SLAVEADDR_WR;         /* Send (SLA+W) to EEPROM */
 625   1          clr_SI;
 626   1          while (!SI);
 627   1          if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -            
 628   1          {
 629   2              I2C_Reset_Flag = 1;       
 630   2              //iputs0("I2C 'Send SLA+W' error\r\n");
 631   2             
 632   2              goto Write_Error_Stop;
 633   2          }
 634   1          
 635   1         
 636   1          /* Step3 */
 637   1          I2DAT = iaddr;             /* Send EEPROM's  Address */
 638   1          clr_SI;
 639   1          while (!SI);
 640   1          if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */
 641   1          {
 642   2              I2C_Reset_Flag = 1;
 643   2              //iputs0("I2C 'Send sub address' error\r\n");
 644   2              goto Write_Error_Stop;
 645   2          }
 646   1       
 647   1      
 648   1          /* Step5 */
 649   1          /* Write data to I2C EEPROM */ 
 650   1      
 651   1          for (u8Count = 0; u8Count < ilen; u8Count++)
 652   1          {
 653   2          
 654   2            I2DAT = sbuf[u8Count];                    /* Send data to EEPROM */
 655   2            clr_SI;
 656   2            while (!SI);
 657   2            if (I2STAT != 0x28)                 /* 0x28:  Data byte in S1DAT has been transmitted; ACK has been 
             -received */
 658   2            {
 659   3               I2C_Reset_Flag = 1;
 660   3               //iputs0("I2C 'Write Data' error\r\n");
 661   3               goto Write_Error_Stop;
 662   3            }   
 663   2         } 
 664   1         
 665   1         /* Step6 */
 666   1      
 667   1         set_STO;                           
 668   1         clr_SI;
 669   1         while (STO);
 670   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 12  

 671   1      
 672   1      //iputs0("I2C write ok\r\n");   //--test
 673   1         
 674   1       
 675   1      Write_Error_Stop: 
 676   1      
 677   1         
 678   1         if (I2C_Reset_Flag)
 679   1         {
 680   2            
 681   2            set_STO;                           
 682   2            clr_SI;
 683   2            while (STO);
 684   2      
 685   2            I2C_SI_Check();
 686   2            I2C_Reset_Flag = 0;
 687   2            //iputs0("I2C Write error, test stop\r\n");
 688   2            
 689   2            //test
 690   2            I2CEN=0;
 691   2            I2CEN=1;       
 692   2         }  
 693   1      
 694   1            
 695   1      }
 696          
 697          
 698          void i2c_read( UINT8 iaddr, UINT8 *sbuf, UINT8 ilen )
 699          {
 700   1          UINT8  u8Count; 
 701   1         
 702   1      
 703   1          /* Step1 */
 704   1          set_STA;                                /* Send Start bit to I2C EEPROM */
 705   1          clr_SI;
 706   1          while (!SI);
 707   1          if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
 708   1          {
 709   2            I2C_Reset_Flag = 1;
 710   2            //iputs0("RD Send STAR' error\r\n");
 711   2            iputs0("Read\r\n");
 712   2            goto Read_Error_Stop;
 713   2          }
 714   1      
 715   1          /* Step2 */
 716   1          I2DAT = (SLAVEADDR_SLA | SLAVEADDR_WR);       /* Send (SLA+W) to EEPROM */
 717   1          clr_STA;                                /* Clear STA and Keep SI value in I2CON */    
 718   1          clr_SI;
 719   1          while (!SI);
 720   1          if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -             
 721   1          {
 722   2            I2C_Reset_Flag = 1;
 723   2            //iputs0("I2C 'Send SLA+W' error\r\n");
 724   2            goto Read_Error_Stop;
 725   2          }
 726   1      
 727   1          /* Step3 */
 728   1          I2DAT = iaddr;             /* Send I2C EEPROM's Address */
 729   1          clr_SI;
 730   1          while (!SI);
 731   1          if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 13  

             -n received */              
 732   1          {
 733   2            I2C_Reset_Flag = 1;
 734   2            //iputs0("I2C 'Send I2C High Byte Address' error\r\n");
 735   2            goto Read_Error_Stop;
 736   2          }
 737   1       
 738   1          /* Step5 */
 739   1          set_STA;                                /* Repeated START */
 740   1          clr_SI; 
 741   1          while (!SI);
 742   1          if (I2STAT != 0x10)                     /* 0x10: A repeated START condition has been transmitted */
 743   1          {
 744   2            I2C_Reset_Flag = 1;
 745   2            //iputs0("I2C 'Send STA' error\r\n");
 746   2            goto Read_Error_Stop;
 747   2          }
 748   1      
 749   1          /* Step6 */
 750   1          clr_STA;                                /* Clear STA and Keep SI value in I2CON */
 751   1          I2DAT = (SLAVEADDR_SLA | SLAVEADDR_RD);       /* Send (SLA+R) to EEPROM */
 752   1          clr_SI;
 753   1          while (!SI);
 754   1          if (I2STAT != 0x40)                     /* 0x40:  SLA+R has been transmitted; ACK has been received */
             -              
 755   1          {
 756   2            I2C_Reset_Flag = 1;
 757   2            //iputs0("I2C 'Send SLA+R' error\r\n");
 758   2            goto Read_Error_Stop;
 759   2          }
 760   1      
 761   1          /* Step7 */                             /* Verify I2C EEPROM data */
 762   1          for (u8Count = 0; u8Count <ilen; u8Count++)
 763   1          {
 764   2              set_AA;                             /* Set Assert Acknowledge Control Bit */
 765   2              clr_SI;
 766   2              while (!SI);
 767   2              if (I2STAT != 0x50)                 /* 0x50:Data byte has been received; NOT ACK has been returned
             - */              
 768   2              {
 769   3                  I2C_Reset_Flag = 1;
 770   3                  //iputs0("I2C 'No Ack' error\r\n");
 771   3                  goto Read_Error_Stop;
 772   3              }
 773   2             
 774   2              sbuf[u8Count] = I2DAT;
 775   2          }
 776   1      
 777   1          /* Step8 */
 778   1          clr_AA;                                 /* Send a NACK to disconnect 24xx64 */
 779   1          clr_SI;
 780   1          while (!SI);
 781   1          if (I2STAT != 0x58)                     /* 0x58:Data byte has been received; ACK has been returned */
 782   1          {
 783   2              I2C_Reset_Flag = 1;
 784   2              //iputs0("I2C 'Ack' error\r\n");
 785   2              goto Read_Error_Stop;
 786   2          }
 787   1          
 788   1         /* Step9 */    
 789   1          clr_SI;
 790   1          set_STO;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 14  

 791   1          
 792   1          while (STO);
 793   1          
 794   1          
 795   1      //iputs0("I2C Read ok\r\n");   //--test
 796   1              
 797   1       
 798   1      Read_Error_Stop: 
 799   1         if (I2C_Reset_Flag)
 800   1         {
 801   2            I2C_SI_Check();
 802   2            //--iputs0("I2C Read error, test stop\r\n");
 803   2            I2C_Reset_Flag = 0;
 804   2            
 805   2            //test
 806   2            I2CEN=0;
 807   2            I2CEN=1; 
 808   2         }
 809   1         
 810   1      }
 811          
 812          
 813          UINT8 get_checksum_8(UINT8 *ival, UINT32 inum)
 814          {
 815   1         UINT32 i =0;
 816   1         UINT8 iret =0;
 817   1         UINT16 isum =0;
 818   1         
 819   1         for (i=0; i<inum; i++)
 820   1         {
 821   2            isum += ival[i];      
 822   2         }
 823   1         
 824   1         iret = (UINT8)(isum & 0xff);
 825   1         
 826   1         return iret;
 827   1         
 828   1      }
 829          
 830          void set_eq(UINT8 ieqtype)
 831          {
 832   1         
 833   1         switch (ieqtype)
 834   1         {
 835   2            case 0:  //BT
 836   2               
 837   2               iputbytes0(seqcmd0,5);
 838   2               break;
 839   2            
 840   2            case 1:  //WN1
 841   2               
 842   2               iputbytes0(seqcmd1,5);
 843   2               break;
 844   2            
 845   2            case 2:  //WN2
 846   2               
 847   2               iputbytes0(seqcmd2,5);  
 848   2               break;      
 849   2            
 850   2            case 3:  //WN3
 851   2               
 852   2               iputbytes0(seqcmd3,5); 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 15  

 853   2               break;
 854   2            
 855   2            case 4:  //FN1
 856   2               
 857   2               iputbytes0(seqcmd4,5);
 858   2               break;
 859   2            
 860   2            case 5:  //FN2
 861   2               
 862   2               iputbytes0(seqcmd5,5);
 863   2               break;      
 864   2             
 865   2            case 6:  //FN3
 866   2               
 867   2               iputbytes0(seqcmd6,5); 
 868   2               break;      
 869   2             
 870   2            default:
 871   2      
 872   2               break;
 873   2            
 874   2         } 
 875   1      
 876   1         Switch_Delay1ms(10);  
 877   1         
 878   1      }
 879          
 880          
 881          void set_realvolume(UINT8 ivol)
 882          {
 883   1         UINT8 icmd[5]={0xa5, 0x03, 0x8b, 0, 0 };
 884   1         
 885   1         icmd[3] = ivol;
 886   1         icmd[4] = get_checksum_8(icmd,4); 
 887   1         
 888   1         iputbytes0(icmd,5);
 889   1         
 890   1      }
 891          
 892          
 893          //#define VOLDELAYMIN 40
 894          #define VOLDELAYMIN 75
 895          
 896          
 897          //volume: from ivol to 0, step 2
 898          void setvolumedown(UINT8 ivol, UINT16 idelaytime )
 899          {
 900   1         UINT16 istepdelay =0;  
 901   1      
 902   1         istepdelay = (UINT16)(idelaytime/ivol);    
 903   1         
 904   1         if(istepdelay < VOLDELAYMIN)
 905   1            istepdelay = VOLDELAYMIN;
 906   1         
 907   1         while (ivol)
 908   1         {
 909   2            set_realvolume(ivol);                  
 910   2            Switch_Delay1ms(istepdelay);  
 911   2            
 912   2            if(ivol >=2)
 913   2               {ivol--; ivol--; } 
 914   2            else
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 16  

 915   2               break;         
 916   2         } 
 917   1         
 918   1       
 919   1         ivol =0;
 920   1         set_realvolume(ivol);                  
 921   1         Switch_Delay1ms(istepdelay);     
 922   1      
 923   1      }  
 924          
 925          
 926          ////volume: from ivol to 0, step 1
 927          //void setvolumedown(UINT8 ivol, UINT16 idelaytime )
 928          //{
 929          //   UINT16 istepdelay =0;  
 930          
 931          //   istepdelay = (UINT16)(idelaytime/ivol);    
 932          //   
 933          //   if(istepdelay < VOLDELAYMIN)
 934          //      istepdelay = VOLDELAYMIN;
 935          //   
 936          //   while (ivol)
 937          //   {
 938          //      set_realvolume(ivol);                  
 939          //      Switch_Delay1ms(istepdelay);  
 940          //      ivol--;    
 941          //   } 
 942          //   
 943          //   set_realvolume(0);                  
 944          //   Switch_Delay1ms(istepdelay);     
 945          
 946          //}  
 947          
 948          
 949          //void setvolumedown(UINT8 ivol, UINT16 idelaytime )
 950          //{
 951          //   UINT16 istepdelay =0;  
 952          
 953          //   istepdelay = (UINT16)(idelaytime/ivol);    
 954          //   
 955          //   if(istepdelay < VOLDELAYMIN)
 956          //      istepdelay = VOLDELAYMIN;
 957          //   
 958          //   while (ivol)
 959          //   {
 960          //      ivol--;                  
 961          //      set_realvolume(ivol);                  
 962          //      Switch_Delay1ms(istepdelay);                    
 963          //   } 
 964          
 965          //}  
 966          
 967          
 968          //void setvolumedown2(UINT8 ivol, UINT16 idelaytime )
 969          //{
 970          //   UINT16 istepdelay =0;  
 971          
 972          //   istepdelay = (UINT16)(idelaytime/ivol);    
 973          //   
 974          //   if(istepdelay < VOLDELAYMIN)
 975          //      istepdelay = VOLDELAYMIN;
 976          //   
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 17  

 977          //   while (ivol>1)
 978          //    {
 979          //      ivol--;                  
 980          //      //ivol--;                  
 981          //      set_realvolume(ivol);                  
 982          //      Switch_Delay1ms(istepdelay);                    
 983          //   } 
 984          
 985          //} 
 986          
 987          
 988          //volume: from 0 to ivol , step 2
 989          void setvolumeup(UINT8 ivol, UINT16 idelaytime )
 990          {
 991   1         UINT16 istepdelay =0;  
 992   1         UINT8 istepvol =0;  
 993   1      
 994   1         istepdelay = (UINT16)(idelaytime/ivol);     
 995   1         
 996   1         if(istepdelay < VOLDELAYMIN)
 997   1            istepdelay = VOLDELAYMIN;   
 998   1         
 999   1         while (istepvol<=ivol)
1000   1         {
1001   2            set_realvolume(istepvol);                  
1002   2            Switch_Delay1ms(istepdelay); 
1003   2      
1004   2            if(ivol <=1)
1005   2               break;
1006   2            else if( istepvol<= (ivol-2) )      
1007   2               {istepvol++; istepvol++; }
1008   2            else
1009   2              break;          
1010   2         }   
1011   1       
1012   1         if(istepvol<ivol)
1013   1         {
1014   2            set_realvolume(ivol);                  
1015   2            Switch_Delay1ms(istepdelay); 
1016   2         }      
1017   1      
1018   1      } 
1019          
1020          
1021          
1022          ////volume: from 0 to ivol, step 1
1023          //void setvolumeup(UINT8 ivol, UINT16 idelaytime )
1024          //{
1025          //   UINT16 istepdelay =0;  
1026          //   UINT8 istepvol =0;  
1027          
1028          //   istepdelay = (UINT16)(idelaytime/ivol);     
1029          //   
1030          //   if(istepdelay < VOLDELAYMIN)
1031          //      istepdelay = VOLDELAYMIN;   
1032          //   
1033          //   while (istepvol<=ivol)
1034          //   {
1035          //      set_realvolume(istepvol);                  
1036          //      Switch_Delay1ms(istepdelay);                    
1037          //      istepvol++;     
1038          //   } 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 18  

1039          
1040          //} 
1041          
1042          
1043          
1044          void set_volume(UINT8 ivol)
1045          {
1046   1         UINT8 icmd[5]={0xa5, 0x03, 0x8b, 0, 0 };
1047   1         
1048   1         if(ivol >10)
1049   1            ivol =10;
1050   1         
1051   1         switch (ivol)
1052   1         {
1053   2            case 0:
1054   2               
1055   2               icmd[3] = 0;
1056   2               break;
1057   2            
1058   2            case 1:
1059   2               
1060   2               icmd[3] = 4;
1061   2               break;
1062   2            
1063   2            case 2:
1064   2            case 3:
1065   2            case 4:
1066   2            case 5:
1067   2            case 6:
1068   2            case 7:
1069   2            case 8:
1070   2            case 9:
1071   2            case 10:
1072   2               
1073   2               icmd[3] = 4 + (ivol-1) *3 ;
1074   2               break;      
1075   2             
1076   2            default:
1077   2      
1078   2               break;
1079   2            
1080   2         }
1081   1         icmd[4] = get_checksum_8(icmd,4); 
1082   1         
1083   1         iputbytes0(icmd,5);   
1084   1      }
1085          
1086          
1087          
1088          //void getadcvalue (UINT8 icomindex) 
1089          //{  
1090          //   UINT8 stemp2[20]={0}; 
1091          //   UINT16 AIN_value=0;
1092          //   double iadc =0;
1093          //   
1094          //   
1095          //   //-------------BAND-----------------
1096          //   
1097          //   Enable_ADC_BandGap;     
1098          //   CKDIV = 0x02;   
1099          
1100          //   
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 19  

1101          //   clr_ADCF;
1102          //   set_ADCS;                             
1103          //   while(ADCF == 0);  
1104          
1105          //   BAND_value =  ADCRH ;
1106          //   BAND_value <<=  4 ;
1107          //   BAND_value |=  ADCRL & 0x0f ;      
1108          
1109          //   CKDIV = 0;   
1110          //   Disable_ADC;      
1111          //      
1112          //   switch (icomindex)
1113          //   {  
1114          //     
1115          //      case 0:      
1116          //         
1117          //         //-------------AIN5-----------------
1118          //         
1119          //         Enable_ADC_AIN5;       
1120          //         
1121          //         clr_ADCF;
1122          //         set_ADCS;                    
1123          
1124          //         while(ADCF == 0);
1125          //         
1126          //         AIN_value =  ADCRH ;
1127          //         AIN_value <<=  4 ;
1128          //         AIN_value |=  ADCRL & 0x0f ;      
1129          //         
1130          //         iadc =   Bandgap_Voltage * AIN_value  / BAND_value;  //mv        
1131          //         iadcvalue = (UINT16)iadc;
1132          //      
1133          //      
1134          //         //iadcvalue_out = ( (INT16) (iadcvalue -  iadcvalue_delay) >>AVRBITCOUNT ) + iadcvalue_delay;
1135          //         //iadcvalue_delay = iadcvalue_out; 
1136          //      
1137          
1138          //         flg_channel=1;
1139          //       
1140          //         Disable_ADC;
1141          //         
1142          //         break;
1143          //      
1144          //         
1145          //      default:
1146          
1147          //         break;
1148          //      
1149          //  }   
1150          //   
1151          //}
1152          
1153          
1154          void getadcvalue () 
1155          {  
1156   1         UINT8 stemp2[20]={0}; 
1157   1         UINT16 AIN_value=0;
1158   1         double iadc =0;
1159   1         
1160   1         
1161   1         //-------------BAND-----------------
1162   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 20  

1163   1         Enable_ADC_BandGap;    
1164   1         //CKDIV = 0x02;   
1165   1      
1166   1         
1167   1         clr_ADCF;
1168   1         set_ADCS;                               
1169   1         while(ADCF == 0);  
1170   1      
1171   1         BAND_value =  ADCRH ;
1172   1         BAND_value <<=  4 ;
1173   1         BAND_value |=  ADCRL & 0x0f ;      
1174   1      
1175   1         //CKDIV = 0;   
1176   1         Disable_ADC;      
1177   1            
1178   1       
1179   1         //-------------AIN5-----------------
1180   1         
1181   1         Enable_ADC_AIN5;      
1182   1         
1183   1         clr_ADCF;
1184   1         set_ADCS;                      
1185   1      
1186   1         while(ADCF == 0);
1187   1         
1188   1         AIN_value =  ADCRH ;
1189   1         AIN_value <<=  4 ;
1190   1         AIN_value |=  ADCRL & 0x0f ;      
1191   1         
1192   1         //iadc =   Bandgap_Voltage * AIN_value  / BAND_value;     //mv        
1193   1         iadc =   Bandgap_Voltage * AIN_value  /  BAND_3300;     //mv        
1194   1         iadcvalue = (UINT16)iadc;
1195   1      
1196   1      
1197   1         //iadcvalue_out = ( (INT16) (iadcvalue -  iadcvalue_delay) >>AVRBITCOUNT ) + iadcvalue_delay;
1198   1         //iadcvalue_delay = iadcvalue_out; 
1199   1      
1200   1         flg_channel=1;
1201   1       
1202   1         Disable_ADC;      
1203   1         
1204   1      }
1205          
1206          
1207          //#define TIMER_DIV12_COUNT_10ms       65536-13334 
1208          //#define TIMER_DIV12_COUNT_3ms           65536-4000
1209          //#define TIMER_DIV12_COUNT_2ms           65536-2667
1210          //#define TIMER_DIV12_COUNT_1ms           65536-1334
1211          //#define TIMER_DIV12_COUNT_500us         65536-667
1212          //#define TIMER_DIV12_COUNT_100us         65536-133
1213          //#define TIMER_DIV12_COUNT_50us       65536-67
1214          
1215          
1216          //#define TIMER_DIV12_COUNT  TIMER_DIV12_COUNT_1ms 
1217          
1218          //void Timer1_ISR (void) interrupt 3 
1219          //{   
1220          //   static UINT8 iscanindex =0;  
1221          
1222          //   itimer1_count1++;     
1223          //   itimer1_count2++;     
1224          //   //itimer1_count3++;     
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 21  

1225          //   
1226          
1227          //   TL1 = TIMER_DIV12_COUNT & 0xFF;       
1228          //   TH1 = TIMER_DIV12_COUNT >> 8 ;    
1229          
1230          //   
1231          //   //getadcvalue(iscanindex);   
1232          //   getadcvalue();   
1233          //   
1234          //   
1235          //   iscanindex=0;
1236          //   //if(iscanindex<4)
1237          //   //   iscanindex++;
1238          //   //else
1239          //   //   iscanindex=0;   
1240          //   
1241          //}
1242          
1243          //void timer1_init (void)
1244          //{
1245          //   
1246          //   TIMER1_MODE1_ENABLE;
1247          
1248          //   clr_T1M;      //  sysclk/12   
1249          //   //set_T1M;      //  sysclk
1250          
1251          //   TL1 = TIMER_DIV12_COUNT & 0xff;       
1252          //   TH1 = TIMER_DIV12_COUNT >> 8 ; 
1253          //   
1254          
1255          //   set_ET1;                                    
1256          //   set_EA;                                     
1257          
1258          //   set_TR1;     //Timer1 run
1259          //   
1260          //}
1261          
1262          
1263          static void Modify_HIRC_Value(void)      
1264          {
1265   1         bit BIT_TMP;
1266   1         unsigned char hircmap0,hircmap1;
1267   1         unsigned int trimvalue16bit;
1268   1         set_IAPEN;
1269   1         IAPAL = 0x30;
1270   1         IAPAH = 0x00;
1271   1         IAPCN = 0X04;
1272   1         set_IAPGO;
1273   1         hircmap0 = IAPFD;
1274   1         IAPAL = 0x31;
1275   1         IAPAH = 0x00;
1276   1         set_IAPGO;
1277   1         hircmap1 = IAPFD;
1278   1         clr_IAPEN;
1279   1         trimvalue16bit = ((hircmap0<<1)+(hircmap1&0x01));
1280   1         trimvalue16bit = trimvalue16bit - 15;
1281   1         hircmap1 = trimvalue16bit&0x01;
1282   1         hircmap0 = trimvalue16bit>>1;
1283   1         TA=0XAA;
1284   1         TA=0X55;
1285   1         RCTRIM0 = hircmap0;
1286   1         TA=0XAA;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 22  

1287   1         TA=0X55;
1288   1         RCTRIM1 = hircmap1;
1289   1      
1290   1      }
1291          
1292          void pwm_init(void)
1293          {  
1294   1         
1295   1         // set up IO
1296   1         P05_PushPull_Mode;
1297   1         
1298   1         //set up PWM2, this will be the noise source DAC
1299   1         PWM2_P05_OUTPUT_ENABLE;
1300   1         PWM_INT_PWM2;   
1301   1         PWM_FALLING_INT;                   //Setting Interrupt happen when PWM0 falling signal
1302   1      
1303   1         PWM_CLOCK_DIV_2;
1304   1         PWMPH = 0x01;                     //Setting PWM period
1305   1         PWMPL = 0xFF;
1306   1         
1307   1         PWM2H = 0x00;                     //PWM2, duty = 1/2 PWM period
1308   1         PWM2L = 0xFF;   
1309   1         
1310   1         //set priority  3
1311   1         EIP  |= (1<<3);   
1312   1         EIPH |= (1<<3);       
1313   1      
1314   1         set_EPWM;                         //Enable PWM interrupt
1315   1         set_EA;                           
1316   1         set_LOAD;
1317   1         //set_PWMRUN;
1318   1      
1319   1      }  
1320          
1321          
1322          void PWM_ISR (void) interrupt 13
1323          {
1324   1         clr_PWMF;                                                 // clear the interrupt flag   
1325   1         //P0f = 1;                                                  // just an I/O marker to show activity   
1326   1      
1327   1      //clr_EA;
1328   1         
1329   1         // Harmonics generator   
1330   1         if(CTR_DIR)
1331   1         {
1332   2            Harm_Val = (Harm_Val + INCR);
1333   2            if (Harm_Val >= 0x1FE)                                 // ramped to max?
1334   2            {   
1335   3               Harm_Val = 0x1FE;
1336   3               CTR_DIR = 0;
1337   3            }
1338   2         }
1339   1         else
1340   1         {
1341   2            Harm_Val = (Harm_Val - INCR);
1342   2            if (Harm_Val <= 0x0)                                    // ramped to zero?
1343   2            {
1344   3               Harm_Val = 1;
1345   3               CTR_DIR = 1;   
1346   3            }
1347   2         }
1348   1      
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 23  

1349   1         // White noise generator (Galois LFSR)
1350   1         LSB = LFSR & 0x01u;                                         // Get LSB (i.e., the output bit)
1351   1         LFSR = (UINT16)LFSR >> 1;                                   // Shift register 
1352   1         if (LSB)                                                    // If the output bit is 1, 
1353   1               LFSR ^= 0xB400u;                                      // Apply polynomial feedback. 
1354   1                  
1355   1         // Sum the noise and harmonics and apply the gain
1356   1         L_OUT = (S16)(((LFSR >> (NOISE_K + 7u))));               // kN . N
1357   1         S_OUT = (S16)((Harm_Val >> HARM_K));                     // kH . H
1358   1         L_OUT = (S16)(L_OUT + S_OUT);                            // kH.H + kN.N
1359   1      
1360   1         // Low Pass Filter (1st order IIR) 
1361   1      //   L_OUT = (S16)(L_OUT - LPF);                              // x[n] - y[n-1]//
1362   1      //   L_OUT = (S16)(L_OUT >> LPF_K);                           // k(x[n] - y[n-1])
1363   1      //   L_OUT = (S16)(L_OUT + LPF);                              // k(x[n] - y[n-1]) + y[n-1]
1364   1         LPF = L_OUT;                                             // y[n] => y[n-1]
1365   1         
1366   1               
1367   1         // set size and range of output data, exceeding range will crash the HW   
1368   1         L_OUT = (UINT16)(L_OUT & 0x1ff);
1369   1         if(L_OUT == 0)
1370   1            L_OUT = 0x0001;
1371   1         if(L_OUT == 0x01ff)
1372   1            L_OUT = 0x01fe;      
1373   1                  
1374   1         // DAC output            
1375   1         PWM2H = (UINT16)(L_OUT >> 8) & 0x01;               // high byte   
1376   1         PWM2L = L_OUT & 0xff;                              // low byte
1377   1         set_LOAD;                                          // latch the updated PWM value to the PWM engine
1378   1         
1379   1         //P0f = 0;                                           // just an I/O marker to show activity
1380   1         
1381   1      //set_EA;
1382   1                 
1383   1      }
1384          
1385          
1386          
1387          ////white noise switch
1388          //void whitenoise_switch(void)
1389          //{
1390          // 
1391          //   switch(WN_MODE)
1392          //   {
1393          //      
1394          // 
1395          //      case 1:     //WN1
1396          //      {
1397          //         LPF_K = 5;
1398          //         HARM_K = 7;
1399          //         NOISE_K = 1;
1400          //         INCR = 0;      
1401          //         break;                     
1402          //      }
1403          //      case 2:     //WN2
1404          //      {
1405          //         LPF_K = 5;
1406          //         HARM_K = 7;
1407          //         NOISE_K = 1;
1408          //         INCR = 0;      
1409          //         break;   
1410          //      }
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 24  

1411          //      case 3:     //WN2
1412          //      {
1413          //         LPF_K = 5;
1414          //         HARM_K = 7;
1415          //         NOISE_K = 1;
1416          //         INCR = 0;      
1417          //         break;                    
1418          //      }
1419          //      
1420          
1421          ////      case 4:     //FN1
1422          ////      {
1423          ////         LPF_K = 6;
1424          ////         HARM_K = 1;
1425          ////         NOISE_K = 3;
1426          ////         INCR = 3;      
1427          ////         break;                     
1428          ////      }
1429          //      case 4:     //FN1
1430          //      {
1431          //         LPF_K = 6;
1432          //         HARM_K = 1;
1433          //         NOISE_K = 3;  //3
1434          //         INCR = 3;      
1435          //         break;                     
1436          //      }
1437          //      
1438          //      
1439          //      case 5:     //FN2
1440          //      {
1441          //         LPF_K = 6;
1442          //         HARM_K = 1;
1443          //         NOISE_K = 2;
1444          //         INCR = 4;      
1445          //         break;                    
1446          //      }
1447          //      case 6:     //FN3
1448          //      {
1449          //         LPF_K = 6;
1450          //         HARM_K = 1;
1451          //         NOISE_K = 2;
1452          //         INCR = 5;      
1453          //         break;                       
1454          //      }           
1455          //      
1456          //   }
1457          //         
1458          //}  
1459          
1460          //white noise switch
1461          void whitenoise_switch(void)
1462          {
1463   1       
1464   1         switch(WN_MODE)
1465   1         {      
1466   2       
1467   2            case 1:     //WN1
1468   2            {
1469   3               LPF_K = 1;   //6
1470   3               HARM_K = 7;
1471   3               NOISE_K = 1;
1472   3               INCR = 0;      
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 25  

1473   3               break;                     
1474   3            }
1475   2            case 2:     //WN2
1476   2            {
1477   3               LPF_K = 1;  //6
1478   3               HARM_K = 7;
1479   3               NOISE_K = 1;
1480   3               INCR = 0;      
1481   3               break;   
1482   3            }
1483   2            case 3:     //WN2
1484   2            {
1485   3               LPF_K = 1;   //6
1486   3               HARM_K = 7;
1487   3               NOISE_K = 1;
1488   3               INCR = 0;      
1489   3               break;                    
1490   3            }      
1491   2      
1492   2            case 4:     //FN1
1493   2            {
1494   3               LPF_K = 1;  //6
1495   3               HARM_K = 2;  //
1496   3               NOISE_K = 3;  //2/3
1497   3               INCR = 3;      
1498   3               break;                     
1499   3            }
1500   2            
1501   2            
1502   2            case 5:     //FN2
1503   2            {
1504   3               LPF_K = 1;  //6
1505   3               HARM_K = 2; //1
1506   3               NOISE_K = 2;
1507   3               INCR = 4;      
1508   3               break;                    
1509   3            }
1510   2            case 6:     //FN3
1511   2            {
1512   3               LPF_K = 1;  //6
1513   3               HARM_K = 2;  //1
1514   3               NOISE_K = 2;
1515   3               INCR = 5;      
1516   3               break;                       
1517   3            }           
1518   2            
1519   2         } 
1520   1               
1521   1      }  
1522          
1523          
1524          UINT8 get_noisevolume(UINT8 imode)
1525          {   
1526   1         UINT8 ivol =0;
1527   1      
1528   1         switch (imode)
1529   1         {
1530   2            
1531   2            case 1:  //WN1
1532   2               ivol = inoisebasevol +4;  
1533   2               break;
1534   2            
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 26  

1535   2            case 2:  //WN2
1536   2               ivol = inoisebasevol +2;   
1537   2               break;
1538   2            
1539   2            
1540   2            case 3:  //WN3
1541   2               ivol = inoisebasevol +0;   
1542   2               break;
1543   2            
1544   2      
1545   2            case 4:  //FN1
1546   2               ivol = inoisebasevol +12;    //11
1547   2               break;
1548   2            
1549   2            
1550   2            case 5:  //FN2
1551   2               ivol = inoisebasevol +9;   
1552   2               break;
1553   2            
1554   2            case 6:  //FN3
1555   2               ivol = inoisebasevol +9;  
1556   2               break;
1557   2            
1558   2            default: 
1559   2      
1560   2               break;       
1561   2         } 
1562   1      
1563   1         return ivol;   
1564   1                  
1565   1      }
1566           
1567          
1568          //void poweron(void)
1569          //{
1570          //   
1571          //   flg_standby =0;
1572          //   
1573          //   
1574          //   if(flg_voicemode ==0)  //BT MODE power on
1575          //   {      
1576          //      
1577          //      //open power
1578          //      P03=1; 
1579          //      flg_power=1;  
1580          //      Switch_Delay1ms(10);            
1581          //      
1582          //      P12=1;   //led
1583          //      
1584          //      
1585          //      //onoff start level
1586          //      P10=1;   
1587          //      //Switch_Delay1ms(2000);  
1588          //      //Switch_Delay1ms(700);  //ok
1589          //      Switch_Delay1ms(1000);  
1590          //      P10=0;  
1591          //      Switch_Delay1ms(100);   
1592          
1593          //      
1594          //      iputbytes0(spoweron,5);
1595          //      //Switch_Delay1ms(10); 
1596          //      Switch_Delay1ms(500); 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 27  

1597          
1598          //      //--Switch_Delay1ms(1000); 
1599          //      //open AMP   --normal
1600          //      P11=1; 
1601          //      Switch_Delay1ms(10); 
1602          //      
1603          //      
1604          //      //send eq cmd  
1605          //      Switch_Delay1ms(100);
1606          //      set_eq(0); 
1607          //      Switch_Delay1ms(10);                     
1608          
1609          
1610          //      //wait connected 
1611          //      //while ( (flg_connected==1) && (iconncount>=1000) ) iconncount++;
1612          //      
1613          //      Switch_Delay1ms(3800);
1614          //      
1615          //      //--set_realvolume(ibtvol); 
1616          //      //Switch_Delay1ms(10);   
1617          //   }
1618          //   
1619          //   else    //Noise MODE  power on
1620          //   {
1621          //      //UINT16 iswitchdelay =0; 
1622          
1623          //      //open power
1624          //      P03=1; 
1625          //      flg_power=1;
1626          //      Switch_Delay1ms(100);            
1627          //      
1628          //      P12=1;   //led
1629          //      
1630          //      //onoff start level
1631          //      P10=1;   
1632          //      //Switch_Delay1ms(700);  //ok
1633          //      Switch_Delay1ms(1000);  
1634          //      P10=0;  
1635          //      Switch_Delay1ms(10); 
1636          
1637          
1638          //      iputbytes0(spoweron2,5);
1639          //      //iputbytes0(spoweron,5);
1640          //      Switch_Delay1ms(200); 
1641          
1642          
1643          //      //send eq cmd  
1644          //      set_eq(WN_MODE); 
1645          //      Switch_Delay1ms(500);  
1646          //      
1647          //     
1648          //      //set new noise
1649          //      whitenoise_switch(); 
1650          //      Switch_Delay1ms(10);  
1651          //      
1652          
1653          //      //Switch_Delay1ms(1000);               
1654          //      //Switch_Delay1ms(500);               
1655          //      set_realvolume(0);               
1656          //      Switch_Delay1ms(100); 
1657          //      
1658          //      pwm_init();   
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 28  

1659          //      set_PWMRUN;    
1660          //      flg_voicemode =1;      //switch to AUX 
1661          
1662          
1663          //      //open AMP
1664          //      P11=1; 
1665          //      Switch_Delay1ms(10);
1666          //      
1667          //      //volume up
1668          //      inoisevolume=get_noisevolume(WN_MODE);
1669          //      setvolumeup(inoisevolume, 500);
1670          
1671          //      P12=0;   //led      
1672          //      
1673          //      //iputs0("led off\r\n");
1674          //      
1675          //      
1676          //      //inoisevolume=get_noisevolume(WN_MODE);               
1677          //      //set_realvolume(inoisevolume); 
1678          //      //Switch_Delay1ms(50);      
1679          //      
1680          //   }     
1681          //   
1682          //}
1683          
1684          
1685          void poweron_BT(void)
1686          {
1687   1       
1688   1         Switch_Delay1ms(10);            
1689   1         
1690   1         
1691   1         //onoff start level
1692   1         P10=1;   
1693   1         //Switch_Delay1ms(2000);  
1694   1         //Switch_Delay1ms(700);  //ok
1695   1         Switch_Delay1ms(1000);  
1696   1         P10=0;  
1697   1         Switch_Delay1ms(100);   
1698   1      
1699   1         
1700   1         iputbytes0(spoweron,5);
1701   1         Switch_Delay1ms(500); 
1702   1      
1703   1         //--Switch_Delay1ms(1000); 
1704   1         //open AMP   --normal
1705   1         P11=1; 
1706   1         Switch_Delay1ms(10); 
1707   1         
1708   1         
1709   1         //send eq cmd  
1710   1         Switch_Delay1ms(100);
1711   1         set_eq(0); 
1712   1         Switch_Delay1ms(10);  
1713   1      
1714   1         
1715   1         Switch_Delay1ms(2000);
1716   1         //--P12=1;   //back led
1717   1         Switch_Delay1ms(1800);
1718   1         
1719   1         
1720   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 29  

1721   1         //--set_realvolume(ibtvol); 
1722   1         //Switch_Delay1ms(10);    
1723   1         
1724   1      }
1725          
1726          
1727          void poweron_AUX(void)
1728          {
1729   1         
1730   1         //Switch_Delay1ms(100);   
1731   1         Switch_Delay1ms(10);   
1732   1         
1733   1         //onoff start level
1734   1         P10=1;   
1735   1         //Switch_Delay1ms(700);  //ok
1736   1         Switch_Delay1ms(1000);  
1737   1         P10=0;  
1738   1         Switch_Delay1ms(10); 
1739   1      
1740   1      
1741   1         iputbytes0(spoweron2,5);
1742   1         //iputbytes0(spoweron,5);
1743   1         Switch_Delay1ms(200); 
1744   1      
1745   1      
1746   1         //send eq cmd  
1747   1         set_eq(WN_MODE); 
1748   1         Switch_Delay1ms(500);  
1749   1         
1750   1        
1751   1         //set new noise
1752   1         whitenoise_switch(); 
1753   1         Switch_Delay1ms(10);  
1754   1         
1755   1              
1756   1         set_realvolume(0);               
1757   1         Switch_Delay1ms(100); 
1758   1         
1759   1         pwm_init();   
1760   1         set_PWMRUN;    
1761   1         flg_voicemode =1;      //switch to AUX 
1762   1      
1763   1      
1764   1         //open AMP
1765   1         P11=1; 
1766   1         Switch_Delay1ms(10);
1767   1         
1768   1         //volume up
1769   1         inoisevolume=get_noisevolume(WN_MODE);
1770   1         setvolumeup(inoisevolume, 500);
1771   1         
1772   1         P12=1;   //back led
1773   1         
1774   1         //inoisevolume=get_noisevolume(WN_MODE);               
1775   1         //set_realvolume(inoisevolume); 
1776   1         //Switch_Delay1ms(50); 
1777   1         
1778   1      }
1779          
1780          
1781          //void poweroff(void)
1782          //{
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 30  

1783          //   
1784          //   UINT8 sbuf1[10] ={0};
1785          //   
1786          //   //pairing led
1787          //   P01=0;
1788          //   
1789          //   //charge led
1790          //   P16=0;     
1791          //   
1792          //   //close pwm
1793          //   clr_EPWM;
1794          //   clr_PWMRUN;            
1795          //   flg_openpwm =0;  
1796          //   
1797          //   
1798          //   if(flg_voicemode ==1)
1799          //   {
1800          //      
1801          //      //volume down
1802          //      inoisevolume=get_noisevolume(WN_MODE);      
1803          //      setvolumedown(inoisevolume,500);       
1804          //      
1805          //      set_realvolume(0);
1806          //      Switch_Delay1ms(10);     
1807          
1808          //      P11=0;
1809          //   }   
1810          //      
1811          
1812          //   if(flg_voicemode ==0)  //BT MODE power off
1813          //   {
1814          //      Switch_Delay1ms(150);  //100
1815          //      
1816          //      P12=0;   //led  
1817          
1818          //      iputbytes0(spoweroff,5);
1819          //      Switch_Delay1ms(10);
1820          
1821          //      Switch_Delay1ms(3500);  
1822          //      
1823          //      
1824          //      P11=0; 
1825          //      Switch_Delay1ms(10);
1826          
1827          //   }
1828          //   else    //Noise MODE power off
1829          //   {
1830          //      UINT8 stemp1[20]={0};
1831          //      UINT16 iswitchdelay=0;
1832          //      
1833          //      P12=0;   //led         
1834          //      
1835          //      
1836          //      //volume down
1837          //      //inoisevolume=get_noisevolume(WN_MODE);      
1838          //      //setvolumedown(inoisevolume,500); 
1839          //      
1840          
1841          //      //set_realvolume(0);
1842          //      //Switch_Delay1ms(3800);   
1843          //     
1844          //      
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 31  

1845          //      //iputbytes0(spoweroff2,5);
1846          //      //iputbytes0(spoweroff,5);
1847          //      //Switch_Delay1ms(10);   
1848          //   }
1849          //   
1850          
1851          //   //open i2c
1852          //   set_I2CEN;
1853          //   //Init_I2C();  
1854          //   
1855          //   //save the datas
1856          //   if(flg_reset ==0)
1857          //   {
1858          //      sbuf1[0] = 1;
1859          //      sbuf1[1] = flg_voicemode;
1860          //      sbuf1[2] = ibtvol;
1861          //      sbuf1[3] = inoisebasevol;
1862          //      sbuf1[4] = WN_MODE;
1863          //   }
1864          //   else
1865          //   {
1866          //      
1867          //      sbuf1[0] = 1;
1868          //      sbuf1[1] = 0;
1869          //      sbuf1[2] = BTVOLSTART;
1870          //      sbuf1[3] = NOISEBASEVOLSTART;
1871          //      sbuf1[4] = 1;      
1872          //   }   
1873          //   
1874          //   //--WriteDataFlash(FIRSTCONFIGREG,sbuf1,5);
1875          //   //Switch_Delay1ms(10);
1876          //   
1877          //   //write datas to i2c
1878          //   i2c_write(FIRSTI2CREG, sbuf1, 5);
1879          //   Switch_Delay1ms(10);
1880          //   
1881          //   
1882          //   P03=0;       //power off
1883          //   flg_power=0;     
1884          //   
1885          //   flg_standby =1;
1886          //}
1887          
1888          
1889          void poweroff_AUX(void)
1890          {
1891   1         
1892   1         UINT8 sbuf1[10] ={0};
1893   1         
1894   1         //UINT8 stemp1[20]={0};
1895   1         //UINT16 iswitchdelay=0;
1896   1         
1897   1         //pairing led
1898   1         P01=0;
1899   1         
1900   1         //charge led
1901   1         P16=0;     
1902   1         
1903   1         
1904   1         //volume down
1905   1         inoisevolume=get_noisevolume(WN_MODE);      
1906   1         setvolumedown(inoisevolume,500);       
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 32  

1907   1         
1908   1         
1909   1         //close pwm
1910   1         clr_EPWM;
1911   1         clr_PWMRUN;            
1912   1         flg_openpwm =0;  
1913   1         
1914   1      
1915   1         P11=0;
1916   1         P12=0;   //back led   
1917   1      
1918   1         //set_realvolume(0);
1919   1         //Switch_Delay1ms(3800); 
1920   1         
1921   1         //iputbytes0(spoweroff2,5);
1922   1         //iputbytes0(spoweroff,5);
1923   1         //Switch_Delay1ms(10);   
1924   1         
1925   1      
1926   1         //----------------------I2C -------------------------
1927   1        
1928   1         //open i2c
1929   1         set_I2CEN;
1930   1         //Init_I2C();  
1931   1         
1932   1         //save the datas
1933   1         if(flg_reset ==0)
1934   1         {
1935   2            sbuf1[0] = 1;
1936   2            sbuf1[1] = flg_voicemode;
1937   2            sbuf1[2] = ibtvol;
1938   2            sbuf1[3] = inoisebasevol;
1939   2            sbuf1[4] = WN_MODE;
1940   2         }
1941   1         else
1942   1         {
1943   2            
1944   2            sbuf1[0] = 1;
1945   2            sbuf1[1] = 0;
1946   2            sbuf1[2] = BTVOLSTART;
1947   2            sbuf1[3] = NOISEBASEVOLSTART;
1948   2            sbuf1[4] = 1;      
1949   2         }   
1950   1         
1951   1         //--WriteDataFlash(FIRSTCONFIGREG,sbuf1,5);
1952   1         //Switch_Delay1ms(10);
1953   1         
1954   1         //write datas to i2c
1955   1         i2c_write(FIRSTI2CREG, sbuf1, 5);
1956   1         Switch_Delay1ms(10);
1957   1         
1958   1         //----------------------I2C ---end----------------------
1959   1         
1960   1         
1961   1         P03=0;       //power off
1962   1         flg_power=0;     
1963   1         
1964   1         flg_standby =1;
1965   1      }
1966          
1967          void poweroff_BT(void)
1968          {
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 33  

1969   1         
1970   1         UINT8 sbuf1[10] ={0};
1971   1         
1972   1         //pairing led
1973   1         P01=0;
1974   1         
1975   1         //charge led
1976   1         P16=0;     
1977   1         
1978   1      
1979   1         Switch_Delay1ms(150);  //100
1980   1         
1981   1         P12=0;   //back led  
1982   1      
1983   1         iputbytes0(spoweroff,5);
1984   1         Switch_Delay1ms(10);
1985   1      
1986   1         Switch_Delay1ms(3500);  
1987   1         
1988   1         
1989   1         P11=0; 
1990   1         Switch_Delay1ms(10);
1991   1      
1992   1      
1993   1      
1994   1         //----------------------I2C -------------------------
1995   1         //open i2c
1996   1         set_I2CEN;
1997   1         //Init_I2C();  
1998   1         
1999   1         //save the datas
2000   1         if(flg_reset ==0)
2001   1         {
2002   2            sbuf1[0] = 1;
2003   2            sbuf1[1] = flg_voicemode;
2004   2            sbuf1[2] = ibtvol;
2005   2            sbuf1[3] = inoisebasevol;
2006   2            sbuf1[4] = WN_MODE;
2007   2         }
2008   1         else
2009   1         {
2010   2            
2011   2            sbuf1[0] = 1;
2012   2            sbuf1[1] = 0;
2013   2            sbuf1[2] = BTVOLSTART;
2014   2            sbuf1[3] = NOISEBASEVOLSTART;
2015   2            sbuf1[4] = 1;      
2016   2         }   
2017   1         
2018   1         //--WriteDataFlash(FIRSTCONFIGREG,sbuf1,5);
2019   1         //Switch_Delay1ms(10);
2020   1         
2021   1         //write datas to i2c
2022   1         i2c_write(FIRSTI2CREG, sbuf1, 5);
2023   1         Switch_Delay1ms(10);
2024   1      
2025   1         //----------------------I2C ---end----------------------
2026   1         
2027   1         
2028   1         P03=0;         //power off
2029   1         flg_power=0;     
2030   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 34  

2031   1         flg_standby =1;
2032   1      }
2033          
2034          
2035          
2036          
2037          void switch2AUX(void)
2038          {
2039   1         UINT8 sbuf1[10] ={0};      
2040   1         
2041   1      //   //volume down 
2042   1      //   setvolumedown(8, 500);   //in tts , can't sent volume command
2043   1         
2044   1         
2045   1         //close AMP                       
2046   1         P11=0; 
2047   1         Switch_Delay1ms(10);     
2048   1      
2049   1         P12=1;   //back led  
2050   1         
2051   1      
2052   1         //send cmd 
2053   1         iputbytes0(sBTAUX_Switch,5);
2054   1         Switch_Delay1ms(1500);
2055   1         
2056   1         
2057   1         set_realvolume(0);                  
2058   1         Switch_Delay1ms(100);    
2059   1         
2060   1         
2061   1         //send eq cmd  
2062   1         set_eq(WN_MODE); 
2063   1         Switch_Delay1ms(100);          
2064   1      
2065   1            
2066   1         //open AMP                     
2067   1         P11=1;
2068   1         Switch_Delay1ms(10);  
2069   1      
2070   1      
2071   1         set_PWMRUN;            
2072   1         flg_openpwm =1;
2073   1      
2074   1      
2075   1         //volume up
2076   1         inoisevolume=get_noisevolume(WN_MODE);   
2077   1         setvolumeup(inoisevolume, 500);
2078   1         Switch_Delay1ms(10);  
2079   1      
2080   1         flg_voicemode =1;      //switch to AUX  
2081   1           
2082   1           
2083   1         //write to i2c
2084   1         set_I2CEN;
2085   1         sbuf1[1] = flg_voicemode;    
2086   1         i2c_write(FIRSTI2CREG+1, sbuf1+1, 1);
2087   1         Switch_Delay1ms(10);   
2088   1         clr_I2CEN; 
2089   1               
2090   1      }  
2091          
2092          
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 35  

2093          void switch2BT(void)
2094          {   
2095   1         UINT8 sbuf1[10] ={0};  
2096   1         
2097   1         flg_stopsendpair =0;   
2098   1         
2099   1         //volume down 
2100   1         inoisevolume=get_noisevolume(WN_MODE);
2101   1         setvolumedown(inoisevolume, 500);
2102   1      
2103   1         
2104   1         //close pwm
2105   1         clr_PWMRUN;
2106   1         flg_openpwm =0;        
2107   1         
2108   1      
2109   1         //play switch tone  
2110   1         //set_realvolume(1);                  
2111   1         //witch_Delay1ms(80);      
2112   1         iputbytes0(sswitchvoice,5);
2113   1         Switch_Delay1ms(1000); 
2114   1      
2115   1         
2116   1         
2117   1         //close AMP                       
2118   1         P11=0; 
2119   1         Switch_Delay1ms(10);  
2120   1         
2121   1      
2122   1         //send switch2BT cmd          
2123   1         iputbytes0(sBTAUX_Switch,5);         
2124   1         Switch_Delay1ms(500); 
2125   1      
2126   1         
2127   1         //send eq cmd  
2128   1         set_eq(0); 
2129   1         Switch_Delay1ms(100);     
2130   1      
2131   1         
2132   1         //reback bt vol
2133   1         //set_realvolume(ibtvol); 
2134   1         //Switch_Delay1ms(10); 
2135   1         
2136   1         
2137   1         //open AMP                     
2138   1         P11=1;
2139   1         Switch_Delay1ms(10); 
2140   1         
2141   1         flg_voicemode =0;      //switch to BT              
2142   1         P12=0;     //back led           
2143   1      
2144   1      
2145   1         //write to i2c
2146   1         set_I2CEN;
2147   1         sbuf1[1] = flg_voicemode;    
2148   1         i2c_write(FIRSTI2CREG+1, sbuf1+1, 1);
2149   1         Switch_Delay1ms(10);   
2150   1         clr_I2CEN; 
2151   1               
2152   1      }
2153          
2154          
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 36  

2155          
2156          void powerkey_scan(void)
2157          {
2158   1         
2159   1         if( P15)
2160   1         {      
2161   2            Switch_Delay1ms(10); 
2162   2            
2163   2            if(P15)           
2164   2               flg_keydown10=1;             
2165   2         }
2166   1         
2167   1         else if(!P15)
2168   1         {
2169   2            if(flg_keydown10==1)      //add
2170   2               Switch_Delay1ms(10);
2171   2            
2172   2            if(!P15)               
2173   2               flg_keydown10 = 0;  
2174   2         }      
2175   1         
2176   1      }
2177          
2178          
2179          #define SHORTPWKEYCOUNT  1  
2180          #define LONGPWKEYCOUNT1  20    
2181          #define LONGPWKEYCOUNT1B 30    
2182          
2183          #define LONGPWKEYCOUNT2 200  //5s+-
2184          
2185          void powerkey_check(void)
2186          {
2187   1         static UINT8 flg_downlongkey1=0;
2188   1         //static UINT32 ilongpowercount2=0;
2189   1         
2190   1         if (flg_downlongkey1==0) 
2191   1         {
2192   2         
2193   2            //powerkey
2194   2            if (flg_keydown10) 
2195   2            {
2196   3               ikeynum10++;            
2197   3      
2198   3               
2199   3               if(flg_power==0)
2200   3               {
2201   4                  if(ikeynum10>=LONGPWKEYCOUNT1B)
2202   4                     {ikeyvalue10 =2; flg_keycome10=1; flg_downlongkey1=1;}             
2203   4               }
2204   3               else
2205   3               {            
2206   4                  if(ikeynum10>=LONGPWKEYCOUNT2)
2207   4                     {ikeyvalue10 =3; flg_keycome10=1; flg_downlongkey1=1;} 
2208   4               }
2209   3      
2210   3            }         
2211   2            else
2212   2            {   
2213   3               
2214   3               if (ikeynum10<1)   
2215   3                   ikeyvalue10 =0;         
2216   3               else if (ikeynum10<LONGPWKEYCOUNT1B)    
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 37  

2217   3                   {ikeyvalue10 =1; flg_keycome10=1;}   
2218   3               else if (ikeynum10<LONGPWKEYCOUNT2)
2219   3                   {ikeyvalue10 =2; flg_keycome10=1;}    
2220   3               else          
2221   3                   {ikeyvalue10 =3; flg_keycome10=1;}  
2222   3                   
2223   3                   
2224   3            } 
2225   2            
2226   2         }
2227   1         else
2228   1         {
2229   2      
2230   2            if (flg_keydown10==0) 
2231   2            {                 
2232   3               flg_downlongkey1=0; 
2233   3               ikeynum10=0; ikeyvalue10=0;    
2234   3            }       
2235   2            
2236   2         }   
2237   1               
2238   1      }
2239          
2240          
2241          void powerkey_process(void)
2242          {      
2243   1      
2244   1         // (AUX and backled)   on/off
2245   1         if(ikeyvalue10 == 1)
2246   1         {
2247   2            //--ikeyvalue10 = 0;
2248   2            
2249   2      
2250   2      #ifdef SNOOZGO   
2251   2            
2252   2            if  ( (flg_voicemode==0) && (P12==0) )     //aux off, led off
2253   2                  flg_switchaux =1;    //switch2AUX();                     
2254   2      
2255   2            if  ( (flg_voicemode==1) && (P12==1) )     //aux on, led on 
2256   2                  switch2BT();        
2257   2      #endif
2258   2      
2259   2            ikeynum10=0; ikeyvalue10=0;        
2260   2         }   
2261   1         
2262   1         
2263   1         //power on/off
2264   1         if(ikeyvalue10 == 2)
2265   1         {
2266   2            //--ikeyvalue10 = 0;
2267   2            
2268   2            //iputs0("power key in\r\n");
2269   2            
2270   2            if(flg_power==0)
2271   2            { 
2272   3               //poweron();
2273   3               
2274   3               flg_standby =0;   
2275   3            
2276   3               //open power
2277   3               P03=1; 
2278   3               
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 38  

2279   3               if(flg_voicemode ==0)  //0 -- BT, 1 -- AUX
2280   3                  poweron_BT(); 
2281   3               else
2282   3                  poweron_AUX();   
2283   3      
2284   3               flg_power=1;           
2285   3               
2286   3            }            
2287   2            else
2288   2            {
2289   3               //--poweroff();
2290   3               
2291   3               if(flg_voicemode ==0)  //0 -- BT, 1 -- AUX
2292   3                  poweroff_BT();
2293   3               else
2294   3                  poweroff_AUX();   
2295   3                           
2296   3            }    
2297   2      
2298   2            ikeynum10=0; ikeyvalue10=0;  
2299   2         } 
2300   1      
2301   1      
2302   1         //control led
2303   1         if(ikeyvalue10 == 3)
2304   1         {
2305   2            //--ikeyvalue10 = 0;
2306   2      
2307   2            if (flg_voicemode==0)     //0 -- BT, 1 -- AUX
2308   2               P12 = ~P12;
2309   2            else         
2310   2               P12 = ~P12;
2311   2      
2312   2            ikeynum10=0; ikeyvalue10=0;        
2313   2         }    
2314   1              
2315   1      }
2316          
2317          #define ADCKEYDELAY  10  //30
2318          void adckey_scan(void)
2319          {
2320   1            
2321   1         if(flg_channel==1)
2322   1         {
2323   2            flg_channel=0;    
2324   2      
2325   2            //iputs0("adc scan...\r\n");   
2326   2            
2327   2           
2328   2            //iadc_key = (UINT16)((double)BAND_value / BAND_3300 * iadcvalue);  
2329   2            iadc_key= iadcvalue;
2330   2            
2331   2            sprintf( sadctemp1, "adckey: %u\r\n", iadc_key);     
2332   2            //sprintf( sadctemp2, "BanD:%u,adc:%u\r\n", BAND_value,iadcvalue_avr); 
2333   2            
2334   2      
2335   2            if(iadc_key >= ADC_VOL_NC2 )
2336   2            {
2337   3      
2338   3               Switch_Delay1ms(ADCKEYDELAY); 
2339   3      
2340   3               if(iadc_key >= ADC_VOL_NC2 )
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 39  

2341   3               {
2342   4                  //if(KEY0_NC_NULL==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("no key2\r\n"); Switch_De
             -lay1ms(2); }
2343   4                  //sprintf( sadcstate, "no key2\r\n");
2344   4                  
2345   4                  KEY0_NC_NULL =1;
2346   4                  flg_keydown1 = 0;
2347   4                  flg_keydown2 = 0;
2348   4                  flg_keydown3 = 0;
2349   4                  flg_keydown4 = 0;   
2350   4                  flg_keydown12 = 0;   
2351   4                  flg_keydown20 = 0;            
2352   4                  
2353   4               }   
2354   3               
2355   3            } 
2356   2      
2357   2      #ifdef SNOOZBUTTON
                    
              //      else if ( (iadc_key >= ADC_BLUETOOTH ) && (iadc_key <= ADC_BLUETOOTH2 ) )   //keep
              //      {
              //      
              //         Switch_Delay1ms(ADCKEYDELAY); 
              
              //         if ( (iadc_key >= ADC_BLUETOOTH ) && (iadc_key <= ADC_BLUETOOTH2 ) )
              //         {
              
              //            if(flg_keydown4==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("btn key\r\n"); Switch_D
             -elay1ms(2); }               
              //            //sprintf( sadcstate, "btn key\r\n");
              
              //         
              //            KEY0_NC_NULL =0;
              //            flg_keydown1 = 0;
              //            flg_keydown2 = 0;
              //            flg_keydown3 = 0;   
              //            flg_keydown4 = 1;   
              //            flg_keydown12 = 0;
              //            flg_keydown20 = 0;
              
              //            ikeyvalue4 = 1;           
              //         }
              //         
              //      } 
                    
              #endif      
2385   2            
2386   2            //else if (iadc_key >= ADC_TONE )
2387   2            else if ( (iadc_key >= ADC_TONE) && (iadc_key<= ADC_TONE2) )
2388   2            {
2389   3            
2390   3               Switch_Delay1ms(ADCKEYDELAY); 
2391   3      
2392   3               if( (iadc_key >= ADC_TONE) && (iadc_key<= ADC_TONE2) )
2393   3               {
2394   4      
2395   4                  if(flg_keydown3==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("tone key\r\n"); Switch_De
             -lay1ms(2); }               
2396   4                  //sprintf( sadcstate, "tone key\r\n");
2397   4      
2398   4               
2399   4                  KEY0_NC_NULL =0;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 40  

2400   4                  flg_keydown1 = 0;
2401   4                  flg_keydown2 = 0;
2402   4                  flg_keydown3 = 1;   
2403   4                  flg_keydown4 = 0;   
2404   4                  flg_keydown12 = 0;
2405   4                  flg_keydown20 = 0;
2406   4      
2407   4                  ikeyvalue3 = 1;           
2408   4               }
2409   3               
2410   3            }
2411   2      
2412   2            //else if (iadc_key >= ADC_VOLADD )
2413   2            else if ( (iadc_key >= ADC_VOLADD )  &&  (iadc_key <= ADC_VOLADD2 )  )
2414   2            {
2415   3      
2416   3               Switch_Delay1ms(ADCKEYDELAY);  
2417   3      
2418   3               if( (iadc_key >= ADC_VOLADD )  &&  (iadc_key <= ADC_VOLADD2 )  )
2419   3               {
2420   4                  //--if(flg_keydown2==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol+ key\r\n"); Switc
             -h_Delay1ms(2); }
2421   4                  //sprintf( sadcstate, "vol+ key\r\n");
2422   4      
2423   4                  if(flg_keydown2==0)
2424   4                     ikeytouch2=1;               
2425   4                  
2426   4                  KEY0_NC_NULL =0;
2427   4                  flg_keydown1 = 0;
2428   4                  flg_keydown2 = 1;
2429   4                  flg_keydown3 = 0;
2430   4                  flg_keydown4 = 0;   
2431   4                  flg_keydown12 = 0;
2432   4                  flg_keydown20 = 0;
2433   4                  
2434   4                  //--ikeyvalue2 = 1; 
2435   4               }     
2436   3               
2437   3            }     
2438   2            //else if(iadc_key >= ADC_VOLDEC )
2439   2            else if( (iadc_key >= ADC_VOLDEC ) && (iadc_key <= ADC_VOLDEC2 ) )
2440   2            {
2441   3               
2442   3               Switch_Delay1ms(ADCKEYDELAY); 
2443   3      
2444   3               if( (iadc_key >= ADC_VOLDEC ) && (iadc_key <= ADC_VOLDEC2 ) )
2445   3               {
2446   4                  //--if(flg_keydown1==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol- key\r\n"); Switch
             -_Delay1ms(2); }
2447   4                  //sprintf( sadcstate, "vol- key\r\n");
2448   4      
2449   4                  if(flg_keydown1==0)
2450   4                     ikeytouch1=1;               
2451   4                  
2452   4                  
2453   4                  KEY0_NC_NULL =0;
2454   4                  flg_keydown1 = 1;
2455   4                  flg_keydown2 = 0;
2456   4                  flg_keydown3 = 0;
2457   4                  flg_keydown4 = 0;   
2458   4                  flg_keydown12 = 0;
2459   4                  flg_keydown20 = 0;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 41  

2460   4                  
2461   4                  //ikeyvalue1 = 1; 
2462   4               }               
2463   3            }   
2464   2      
2465   2            //else if(iadc_key >= ADC_VOLBOTH )
2466   2            else if( (iadc_key >= ADC_VOLBOTH ) && (iadc_key <= ADC_VOLBOTH2 ) )
2467   2            {
2468   3               
2469   3               Switch_Delay1ms(ADCKEYDELAY); 
2470   3      
2471   3               if( (iadc_key >= ADC_VOLBOTH ) && (iadc_key <= ADC_VOLBOTH2 ) )
2472   3               {
2473   4                  //if(flg_keydown12==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol22 key\r\n"); Switch
             -_Delay1ms(2); }
2474   4                  //sprintf( sadcstate, "vol22 key\r\n");      
2475   4                  
2476   4                  KEY0_NC_NULL =0;
2477   4                  flg_keydown1 = 0;
2478   4                  flg_keydown2 = 0;
2479   4                  flg_keydown3 = 0;
2480   4                  flg_keydown4 = 0;   
2481   4                  flg_keydown12 = 1;
2482   4                  flg_keydown20 = 0;
2483   4                  
2484   4                  //ikeyvalue12 = 1; 
2485   4               }   
2486   3               
2487   3            } 
2488   2      
2489   2            //else if(iadc_key <= ADC_VOL_NC )
2490   2            //{
2491   2            //   
2492   2            //   Switch_Delay1ms(ADCKEYDELAY); 
2493   2      
2494   2            //   if(iadc_key <= ADC_VOL_NC )
2495   2            //   {
2496   2            //      if(KEY0_NC_NULL2==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("no key-\r\n"); Switch_D
             -elay1ms(2); }
2497   2            //      //sprintf( sadcstate, "vol0 key\r\n");      
2498   2            //      
2499   2            //      KEY0_NC_NULL =0;
2500   2            //      flg_keydown1 = 0;
2501   2            //      flg_keydown2 = 0;
2502   2            //      flg_keydown3 = 0;
2503   2            //      flg_keydown4 = 0;   
2504   2            //      flg_keydown12 = 0;
2505   2            //      flg_keydown20 = 0;
2506   2            //      KEY0_NC_NULL2 =1;
2507   2            
2508   2            //   }   
2509   2            //   
2510   2            //} 
2511   2      
2512   2      
2513   2            else 
2514   2            {         
2515   3      
2516   3               //--if(flg_keydown20==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("err key\r\n"); Switch_De
             -lay1ms(2); }
2517   3               //sprintf( sadcstate, "vol20 key\r\n");      
2518   3               
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 42  

2519   3               KEY0_NC_NULL =0;
2520   3               flg_keydown1 = 0;
2521   3               flg_keydown2 = 0;
2522   3               flg_keydown3 = 0;
2523   3               flg_keydown4 = 0;   
2524   3               flg_keydown12 = 0;
2525   3               
2526   3               flg_keydown20 = 1;         
2527   3               
2528   3            }
2529   2            
2530   2             
2531   2         }  
2532   1      
2533   1      }
2534          
2535          //#define ADCKEYDELAY  10  //30
2536          //void adckey_scan(void)
2537          //{
2538          //      
2539          //   if(flg_channel==1)
2540          //   {
2541          //      flg_channel=0;    
2542          
2543          //      //iputs0("adc scan...\r\n");   
2544          //      
2545          //     
2546          //      //iadc_key = (UINT16)((double)BAND_value / BAND_3300 * iadcvalue);  
2547          //      iadc_key= iadcvalue;
2548          //      
2549          //      //sprintf( sadctemp1, "adckey: %u\r\n", iadc_key);     
2550          //      //sprintf( sadctemp2, "BanD:%u,adc:%u\r\n", BAND_value,iadcvalue_avr); 
2551          //      
2552          
2553          //      if(iadc_key >= ADC_VOL_NC2 )
2554          //      {
2555          
2556          //         Switch_Delay1ms(ADCKEYDELAY); 
2557          
2558          //         if(iadc_key >= ADC_VOL_NC2 )
2559          //         {
2560          //            //if(KEY0_NC_NULL==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("no key2\r\n"); Switch_
             -Delay1ms(2); }
2561          //            //sprintf( sadcstate, "no key2\r\n");
2562          //            
2563          //            KEY0_NC_NULL =1;
2564          //            flg_keydown1 = 0;
2565          //            flg_keydown2 = 0;
2566          //            flg_keydown3 = 0;
2567          //            flg_keydown4 = 0;   
2568          //            flg_keydown12 = 0;        
2569          //            
2570          //         }   
2571          //         
2572          //      } 
2573          
2574          //#ifdef SNOOZBUTTON
2575          //      
2576          //      //else if (iadc_key >= ADC_BLUETOOTH )    //keep
2577          //      //{
2578          
2579          //      //   Switch_Delay1ms(ADCKEYDELAY); 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 43  

2580          
2581          //      //   if(iadc_key >= ADC_BLUETOOTH )
2582          //      //   {
2583          
2584          //      //      if(flg_keydown4==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("btn key\r\n"); Switch
             -_Delay1ms(2); }               
2585          //      //      //sprintf( sadcstate, "btn key\r\n");
2586          
2587          //      //   
2588          //      //      KEY0_NC_NULL =0;
2589          //      //      flg_keydown1 = 0;
2590          //      //      flg_keydown2 = 0;
2591          //      //      flg_keydown3 = 0;   
2592          //      //      flg_keydown4 = 1;   
2593          //      //      flg_keydown12 = 0;
2594          
2595          //      //      ikeyvalue4 = 1;           
2596          //      //   }
2597          //      //   
2598          //      //} 
2599          //      
2600          //#endif      
2601          //      
2602          //      //else if (iadc_key >= ADC_TONE )
2603          //      else if ( (iadc_key >= ADC_TONE) && (iadc_key<= ADC_TONE2) )
2604          //      {
2605          //      
2606          //         Switch_Delay1ms(ADCKEYDELAY); 
2607          
2608          //         if( (iadc_key >= ADC_TONE) && (iadc_key<= ADC_TONE2) )
2609          //         {
2610          
2611          //            //--if(flg_keydown3==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("tone key\r\n"); Swi
             -tch_Delay1ms(2); }               
2612          //            //sprintf( sadcstate, "tone key\r\n");
2613          
2614          //         
2615          //            KEY0_NC_NULL =0;
2616          //            flg_keydown1 = 0;
2617          //            flg_keydown2 = 0;
2618          //            flg_keydown3 = 1;   
2619          //            flg_keydown4 = 0;   
2620          //            flg_keydown12 = 0;
2621          
2622          //            ikeyvalue3 = 1;           
2623          //         }
2624          //         
2625          //      }
2626          
2627          //      //else if (iadc_key >= ADC_VOLADD )
2628          //      else if ( (iadc_key >= ADC_VOLADD )  &&  (iadc_key <= ADC_VOLADD2 )  )
2629          //      {
2630          
2631          //         Switch_Delay1ms(ADCKEYDELAY);  
2632          
2633          //         if( (iadc_key >= ADC_VOLADD )  &&  (iadc_key <= ADC_VOLADD2 )  )
2634          //         {
2635          //            //if(flg_keydown2==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol+ key\r\n"); Switc
             -h_Delay1ms(2); }
2636          //            //sprintf( sadcstate, "vol+ key\r\n");
2637          
2638          //            if(flg_keydown2==0)
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 44  

2639          //               ikeytouch2=1;               
2640          //            
2641          //            KEY0_NC_NULL =0;
2642          //            flg_keydown1 = 0;
2643          //            flg_keydown2 = 1;
2644          //            flg_keydown3 = 0;
2645          //            flg_keydown4 = 0;   
2646          //            flg_keydown12 = 0;
2647          //            
2648          //            //--ikeyvalue2 = 1; 
2649          //         }     
2650          //         
2651          //      }     
2652          //      //else if(iadc_key >= ADC_VOLDEC )
2653          //      else if( (iadc_key >= ADC_VOLDEC ) && (iadc_key <= ADC_VOLDEC2 ) )
2654          //      {
2655          //         
2656          //         Switch_Delay1ms(ADCKEYDELAY); 
2657          
2658          //         if( (iadc_key >= ADC_VOLDEC ) && (iadc_key <= ADC_VOLDEC2 ) )
2659          //         {
2660          //            //--if(flg_keydown1==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol- key\r\n"); Swit
             -ch_Delay1ms(2); }
2661          //            //sprintf( sadcstate, "vol- key\r\n");
2662          
2663          //            if(flg_keydown1==0)
2664          //               ikeytouch1=1;               
2665          //            
2666          //            
2667          //            KEY0_NC_NULL =0;
2668          //            flg_keydown1 = 1;
2669          //            flg_keydown2 = 0;
2670          //            flg_keydown3 = 0;
2671          //            flg_keydown4 = 0;   
2672          //            flg_keydown12 = 0;
2673          //            
2674          //            //ikeyvalue1 = 1; 
2675          //         }               
2676          //      }   
2677          
2678          //      //else if(iadc_key >= ADC_VOLBOTH )
2679          //      else if( (iadc_key >= ADC_VOLBOTH ) && (iadc_key <= ADC_VOLBOTH2 ) )
2680          //      {
2681          //         
2682          //         Switch_Delay1ms(ADCKEYDELAY); 
2683          
2684          //         if( (iadc_key >= ADC_VOLBOTH ) && (iadc_key <= ADC_VOLBOTH2 ) )
2685          //         {
2686          //            //if(flg_keydown12==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol22 key\r\n"); Swit
             -ch_Delay1ms(2); }
2687          //            //sprintf( sadcstate, "vol22 key\r\n");      
2688          //            
2689          //            KEY0_NC_NULL =0;
2690          //            flg_keydown1 = 0;
2691          //            flg_keydown2 = 0;
2692          //            flg_keydown3 = 0;
2693          //            flg_keydown4 = 0;   
2694          //            flg_keydown12 = 1;
2695          //            
2696          //            //ikeyvalue12 = 1; 
2697          //         }   
2698          //         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 45  

2699          //      } 
2700          
2701          //      //else if(iadc_key <= ADC_VOL_NC )
2702          //      //{
2703          //      //   
2704          //      //   Switch_Delay1ms(ADCKEYDELAY); 
2705          
2706          //      //   if(iadc_key <= ADC_VOL_NC )
2707          //      //   {
2708          //      //      if(flg_keydown12==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("no key-\r\n"); Switch
             -_Delay1ms(2); }
2709          //      //      //sprintf( sadcstate, "vol22 key\r\n");      
2710          //      //      
2711          //      //      KEY0_NC_NULL =0;
2712          //      //      flg_keydown1 = 0;
2713          //      //      flg_keydown2 = 0;
2714          //      //      flg_keydown3 = 0;
2715          //      //      flg_keydown4 = 0;   
2716          //      //      flg_keydown12 = 0;
2717          
2718          //      //   }   
2719          //      //   
2720          //      //}       
2721          //       
2722          //   }  
2723          
2724          //}
2725          
2726          
2727          
2728          
2729          #define VOLKEYCOUNT1   7 
2730          #define VOLKEYCOUNT1B  8 
2731          #define VOLKEYCOUNT2   35
2732          
2733          #define TONEKEYCOUNT1  8 
2734          #define LONGKEYCOUNT3  400   //5S-
2735          void adckey_check(void)
2736          {   
2737   1         static UINT8 flg_downlongkey3=0;
2738   1         static UINT8 flg_downlongkey12=0;
2739   1         
2740   1         //key1 vol-   
2741   1         if (flg_keydown1) 
2742   1         {
2743   2            ikeynum1++;
2744   2         }         
2745   1         else
2746   1         {      
2747   2            ikeynum1 =0;
2748   2            ikeytouch1 = 0;
2749   2         }   
2750   1         
2751   1               
2752   1         //key1 vol-
2753   1         if( ( (ikeytouch1 == 1 ) && (ikeynum1 >=VOLKEYCOUNT1) ) || (ikeynum1 >=VOLKEYCOUNT2) ) 
2754   1         {
2755   2            ikeynum1 = 0;
2756   2            ikeytouch1 = 0;
2757   2            ikeyvalue1=1;
2758   2         }
2759   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 46  

2760   1      
2761   1         //key2 vol+   
2762   1         if (flg_keydown2) 
2763   1         {  
2764   2            ikeynum2++;
2765   2         }         
2766   1         else
2767   1         {      
2768   2            ikeynum2 =0;
2769   2            ikeytouch2=0;
2770   2         }  
2771   1         
2772   1         //key2 vol+
2773   1         if( ( (ikeytouch2 == 1 ) && (ikeynum2 >=VOLKEYCOUNT1) ) || (ikeynum2 >=VOLKEYCOUNT2) ) 
2774   1         {
2775   2            ikeynum2 = 0;
2776   2            ikeytouch2 = 0;
2777   2            ikeyvalue2=1;
2778   2         }
2779   1         
2780   1         
2781   1         //key3 tone
2782   1         if (flg_downlongkey3==0)  
2783   1         {   
2784   2            
2785   2            if (flg_keydown3)  //如果在这里加一个flg_keyup==1防止长按后连按，则逻辑上更标准一些
2786   2            {
2787   3               ikeynum3++;   
2788   3               
2789   3               if(ikeynum3>=LONGKEYCOUNT2)
2790   3                  {ikeyvalue3 =2; flg_keycome3=1; flg_downlongkey3=1;}  //如判断连按，这里需加一句flg_keyup=0
2791   3      
2792   3            }         
2793   2            else
2794   2            {
2795   3               
2796   3               //if (ikeynum3<1) 
2797   3               if (ikeynum3<TONEKEYCOUNT1) 
2798   3                  {ikeyvalue3 =0; }
2799   3               
2800   3               else if( (ikeynum3>=TONEKEYCOUNT1) && (ikeynum3<LONGKEYCOUNT2) )
2801   3                   {ikeyvalue3 =1; flg_keycome3=1;}  
2802   3                   
2803   3               //else          
2804   3               else if(ikeynum3>=LONGKEYCOUNT2)               
2805   3                   {ikeyvalue3 =2; flg_keycome3=1;}  
2806   3                   
2807   3               ikeynum3=0;    
2808   3                   
2809   3            } 
2810   2            
2811   2         }
2812   1         else
2813   1         {
2814   2      
2815   2            if (flg_keydown3==0) 
2816   2            {                 
2817   3               flg_downlongkey3=0; 
2818   3               ikeynum3=0; ikeyvalue3=0;    
2819   3            }  
2820   2            else
2821   2               ;//ikeynum3=0;      //这样的处理，会重新计数，会触发连按   //所以要注释
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 47  

2822   2            
2823   2         }   
2824   1         
2825   1         //key12 volboth
2826   1         if (flg_downlongkey12==0) 
2827   1         {   
2828   2            
2829   2            if (flg_keydown12) 
2830   2            {
2831   3               ikeynum12++;   
2832   3               
2833   3               //P0f =1;
2834   3               if(ikeynum12>=LONGKEYCOUNT3)
2835   3                  {ikeyvalue12 =2; flg_keycome12=1; flg_downlongkey12=1;  
2836   4                   //P0f=0;
2837   4                  } 
2838   3      
2839   3            }         
2840   2            else
2841   2            {
2842   3               P16=0;  
2843   3               
2844   3               if (ikeynum12<1) 
2845   3                   ikeyvalue12 =0;
2846   3               else if (ikeynum12<LONGKEYCOUNT3)
2847   3                   {ikeyvalue12 =1; flg_keycome12=1;}    
2848   3               else          
2849   3                   {ikeyvalue12 =2; flg_keycome12=1;}  
2850   3                   
2851   3            } 
2852   2            
2853   2         }
2854   1         else
2855   1         {
2856   2      
2857   2            if (flg_keydown12==0) 
2858   2            {                 
2859   3               flg_downlongkey12=0; 
2860   3               ikeynum12=0; ikeyvalue12=0;    
2861   3            }       
2862   2            else 
2863   2               ; //keynum3=0;      
2864   2         }      
2865   1               
2866   1      }   
2867           
2868          
2869          void switchnoise(void)
2870          {
2871   1         UINT8 stemp[38]={0};
2872   1         UINT8 sbuf1[10] ={0};   
2873   1         
2874   1            
2875   1         //volume down 
2876   1         inoisevolume=get_noisevolume(WN_MODE);
2877   1         setvolumedown(inoisevolume, 500);
2878   1         
2879   1         
2880   1         //close AMP                       
2881   1         P11 =0; 
2882   1         Switch_Delay1ms(10);  
2883   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 48  

2884   1         clr_PWMRUN;
2885   1         flg_openpwm =0;    
2886   1      
2887   1          
2888   1         //get new noise mode
2889   1         WN_MODE++;
2890   1         if(WN_MODE >= 7)
2891   1            WN_MODE = 1;  
2892   1      
2893   1         
2894   1         //set new noise
2895   1         whitenoise_switch(); 
2896   1         Switch_Delay1ms(10);    
2897   1         
2898   1      
2899   1         //send eq cmd     
2900   1         set_eq(WN_MODE); 
2901   1         Switch_Delay1ms(100);  
2902   1         
2903   1         
2904   1         //open AMP     
2905   1         pwm_init();   
2906   1         set_PWMRUN;
2907   1         flg_openpwm =1;     
2908   1      
2909   1         P11 =1; 
2910   1         Switch_Delay1ms(10);  
2911   1      
2912   1      
2913   1         //play switch tone   
2914   1         if( WN_MODE ==1) 
2915   1         {      
2916   2            //set_realvolume(1);
2917   2            ////Switch_Delay1ms(75); //ok  
2918   2            //Switch_Delay1ms(80);   
2919   2            
2920   2            clr_PWMRUN;
2921   2            flg_openpwm =0;  
2922   2               
2923   2            iputbytes0(sswitchvoice,5);
2924   2            Switch_Delay1ms(1000); 
2925   2      
2926   2            pwm_init();   
2927   2            set_PWMRUN;
2928   2            flg_openpwm =1;
2929   2         }
2930   1      
2931   1      
2932   1         //volume up
2933   1         inoisevolume=get_noisevolume(WN_MODE);
2934   1         setvolumeup(inoisevolume, 500);
2935   1      
2936   1         
2937   1         
2938   1         //write to i2c
2939   1         set_I2CEN;
2940   1         sbuf1[4] = WN_MODE;
2941   1         i2c_write(FIRSTI2CREG+4, sbuf1+4, 1);
2942   1         Switch_Delay1ms(10);   
2943   1         clr_I2CEN;  
2944   1      
2945   1         //sprintf(stemp,"mode: %bu,%bu,%bu\r\n",WN_MODE,inoisebasevol,inoisevolume );
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 49  

2946   1         //iputs0(stemp);
2947   1         //Switch_Delay1ms(20); 
2948   1                  
2949   1      } 
2950          
2951          
2952          void adckey_process(void)
2953          {
2954   1         UINT8 sbuf1[10] ={0};
2955   1         
2956   1         //key1  vol-
2957   1         //if( (ikeyvalue1==1) && (flg_keydown1==0) )
2958   1         if (ikeyvalue1==1)
2959   1         {
2960   2            ikeyvalue1=0;    
2961   2      
2962   2            if(flg_reset ==1) return;      
2963   2            
2964   2            if(flg_voicemode==0)   //0 -- BT, 1 -- AUX
2965   2            {         
2966   3               iputbytes0(svoldec,5);  
2967   3               Switch_Delay1ms(10);          
2968   3               
2969   3               //if(ibtvol >0)
2970   3               //   ibtvol--;         
2971   3      
2972   3               //set_realvolume(ibtvol); 
2973   3               //Switch_Delay1ms(10); 
2974   3            } 
2975   2            else
2976   2            {
2977   3               if(inoisebasevol >0)
2978   3                  inoisebasevol--;
2979   3               
2980   3               inoisevolume=get_noisevolume(WN_MODE);
2981   3               set_realvolume(inoisevolume); 
2982   3               Switch_Delay1ms(10);  
2983   3               
2984   3               
2985   3               //write to i2c
2986   3               set_I2CEN;
2987   3               sbuf1[3] = inoisebasevol;      
2988   3               i2c_write(FIRSTI2CREG+3, sbuf1+3, 1);
2989   3               Switch_Delay1ms(10);   
2990   3               clr_I2CEN;        
2991   3               
2992   3            }   
2993   2            
2994   2      //--iputs0("v- in\r\n");      
2995   2            
2996   2         }
2997   1      
2998   1         
2999   1         //key2  vol+
3000   1         //if( (ikeyvalue2==1) && (flg_keydown2==0) )
3001   1         if( ikeyvalue2==1)
3002   1         {
3003   2            ikeyvalue2=0;
3004   2            
3005   2            if(flg_reset ==1) return;      
3006   2      
3007   2            if(flg_voicemode==0)   //0 -- BT, 1 -- AUX
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 50  

3008   2            {        
3009   3               iputbytes0(svoladd,5); 
3010   3               Switch_Delay1ms(10);         
3011   3      
3012   3               //if( ibtvol < BTVOLTOP )
3013   3               //   ibtvol++;    
3014   3      
3015   3               //set_realvolume(ibtvol); 
3016   3               //Switch_Delay1ms(10);       
3017   3            } 
3018   2            else
3019   2            {
3020   3               if( inoisebasevol < NOISEBASEVOLTOP )
3021   3                  inoisebasevol++;
3022   3               
3023   3               inoisevolume=get_noisevolume(WN_MODE);
3024   3               set_realvolume(inoisevolume); 
3025   3               Switch_Delay1ms(10);  
3026   3               
3027   3               
3028   3               //write to i2c
3029   3               set_I2CEN;
3030   3               sbuf1[3] = inoisebasevol;      
3031   3               i2c_write(FIRSTI2CREG+3, sbuf1+3, 1);
3032   3               Switch_Delay1ms(10);   
3033   3               clr_I2CEN;         
3034   3            } 
3035   2      
3036   2      //--iputs0("v+ in\r\n");
3037   2            
3038   2      
3039   2         }   
3040   1      
3041   1      
3042   1         //key3 tone
3043   1         if  (flg_keycome3==1 )
3044   1         {
3045   2            flg_keycome3=0;
3046   2      
3047   2            if (ikeyvalue3 ==1)      //short 
3048   2            {
3049   3               
3050   3               ikeynum3=0; ikeyvalue3=0; 
3051   3               
3052   3      ////         if(flg_voicemode ==0)  //BT MODE
3053   3      ////         {
3054   3      ////            iputbytes0(splaypause,5);
3055   3      ////            Switch_Delay1ms(10);
3056   3      ////         }
3057   3      ////         else if(flg_voicemode ==1)  //AUX MODE
3058   3      ////         {      
3059   3      ////            switchnoise();  
3060   3      ////         }
3061   3      
3062   3               
3063   3      #ifdef SNOOZGO   
3064   3               
3065   3               if(flg_voicemode==0)    //0 -- BT, 1-- AUX               
3066   3                  //switch2AUX();  
3067   3                  flg_switchaux =1;         
3068   3      
3069   3               else  
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 51  

3070   3                  switch2BT();
3071   3               
3072   3      #endif
3073   3               
3074   3      iputs0("tonekey in\r\n");
3075   3               
3076   3            }
3077   2      
3078   2            //switch BT and AUX 
3079   2            if (ikeyvalue3 ==2)   //long
3080   2            {  
3081   3               
3082   3               //ikeynum3=0; ikeyvalue3=0;     //这样的处理，会重新计数，会触发连按    
3083   3               ikeyvalue3=0;                   //这里的处理，不会重新计数，不会触发连按    
3084   3      
3085   3      ////#ifdef SNOOZGO   
3086   3      ////         
3087   3      ////         if(flg_voicemode==0)    //0 -- BT, 1-- AUX               
3088   3      ////            //switch2AUX();  
3089   3      ////            flg_switchaux =1;         
3090   3      
3091   3      ////         else  
3092   3      ////            switch2BT();
3093   3      ////         
3094   3      ////#endif
3095   3      
3096   3               
3097   3      iputs0("tonekey in2\r\n");      
3098   3               
3099   3            }
3100   2             
3101   2         }  
3102   1      
3103   1         
3104   1         //key12 volboth
3105   1         if  (flg_keycome12==1 )
3106   1         {
3107   2            flg_keycome12=0;
3108   2      
3109   2            if (ikeyvalue12 ==1)      //short 
3110   2            {         
3111   3               ikeynum12=0; ikeyvalue12=0;         
3112   3               
3113   3               ;  //nothing       
3114   3            }
3115   2      
3116   2            //restore factory settings
3117   2            if (ikeyvalue12 ==2)   //long
3118   2            {
3119   3               ikeynum12=0; ikeyvalue12=0;         
3120   3      
3121   3               flg_reset =1; 
3122   3               
3123   3               
3124   3               //send cmd 
3125   3               iputbytes0(sreset,5); 
3126   3               Switch_Delay1ms(1000);  
3127   3               
3128   3               
3129   3               //power off
3130   3               if(flg_voicemode ==0)  //0 -- BT, 1 -- AUX
3131   3                  poweroff_BT();
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 52  

3132   3               else
3133   3                  poweroff_AUX();  
3134   3               
3135   3            }
3136   2             
3137   2         }    
3138   1         
3139   1         if (ikeyvalue4==1)
3140   1         {
3141   2            ikeyvalue4=0;
3142   2            
3143   2            ;  //for snooz button
3144   2         }       
3145   1         
3146   1         
3147   1      }
3148                
3149          void waitpairing(void)
3150          {
3151   1         if (flg_pairing ==1) 
3152   1            return;
3153   1         
3154   1         flg_switchaux =0;         
3155   1         switch2AUX();    
3156   1      }   
3157          
3158          
3159          
3160          #define SVERNO "1564"         
3161          #define UARTDELAYTIMES 6
3162          #define PAIR_LEDCOUNT   50      //500MS+
3163          
3164          //#define PAIR_TONECOUNT  100     //1S+
3165          //#define PAIR_TONECOUNT  320     //3.4S+ 
3166          //#define PAIR_TONECOUNT  310     //3.3S+     
3167          //#define PAIR_TONECOUNT  300     //3.2S+     
3168          #define PAIR_TONECOUNT  330       //3.5S+     
3169            
3170          //#define PAIR_SWITHCOUNT  330       //ok   
3171          #define PAIR_SWITHCOUNT  380      //4.0s+ 
3172          
3173          
3174          void main (void)
3175          {
3176   1         UINT8 stemp[20]={0};    
3177   1         UINT8 sbuf1[10]={0};
3178   1         UINT8 sbuf2[10]={0};   
3179   1         
3180   1         P00_Input_Mode;    //USB DET
3181   1         P17_Input_Mode;    //CHARGE DONE
3182   1         P30_Input_Mode;    //BAT DET
3183   1         
3184   1         
3185   1         InitialUART0_Timer3(115200); 
3186   1         Timer0_Delay1ms(10); 
3187   1         
3188   1      //   iputs0("start................\r\n"); 
3189   1         iputs0("start");  
3190   1         iputs0(SVERNO);  
3191   1         iputs0("............\r\n");  
3192   1         Timer0_Delay1ms(10);      
3193   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 53  

3194   1         
3195   1         //set systemclock
3196   1         set_HIRCST;
3197   1         
3198   1      
3199   1         //adc bandgap
3200   1         READ_BANDGAP();   
3201   1         sprintf (stemp,"band vol = %6.2f\r\n",Bandgap_Voltage); 
3202   1         //--iputs0(stemp);    
3203   1      
3204   1      
3205   1         //main power     
3206   1         P15_Input_Mode;   
3207   1         P03_PushPull_Mode;   
3208   1         P03=0;    
3209   1         
3210   1         
3211   1         //BT ONOFF
3212   1         P10_PushPull_Mode;
3213   1         P10=0;
3214   1         
3215   1         
3216   1         //AMP CTRL
3217   1         P11_PushPull_Mode;
3218   1         P11=0;   
3219   1         
3220   1         
3221   1         //LED P12
3222   1         P12_PushPull_Mode;
3223   1         P12 = 0;  //back led
3224   1      
3225   1      
3226   1         //---------V1.4---add--------
3227   1      
3228   1         //LED pairing 
3229   1         P01_PushPull_Mode;
3230   1         P01=0;  
3231   1      
3232   1         //LED charge
3233   1         P16_PushPull_Mode;
3234   1         P16=1;  
3235   1         
3236   1         //paring det
3237   1         P02_Input_Mode; 
3238   1         
3239   1         
3240   1      //   P00_Input_Mode;    //USB DET
3241   1      //   P17_Input_Mode;    //CHARGE DONE
3242   1      //   P30_Input_Mode;    //BAT DET
3243   1      
3244   1      
3245   1         //---------V1.4----end-------   
3246   1          
3247   1         //pwm init
3248   1         pwm_init();     
3249   1      
3250   1      
3251   1         //i2c init
3252   1         Init_I2C();     
3253   1         
3254   1         //read from i2c
3255   1         i2c_read(FIRSTI2CREG, sbuf2, 5); 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 54  

3256   1         
3257   1         //close i2c
3258   1         Timer0_Delay1ms(2); 
3259   1         clr_I2CEN; 
3260   1         
3261   1         
3262   1         //read the datas
3263   1         //--ReadDataFlash( FIRSTCONFIGREG,sbuf2,5);    
3264   1         
3265   1         //sprintf (stemp,"reg: %bu,%bu,%bu,%bu,%bu\r\n",sbuf2[0],sbuf2[1],sbuf2[2],sbuf2[3],sbuf2[4]); 
3266   1         sprintf (stemp,"reg: %bu,%bu,%bu,%bu,%bu\r\n",sbuf2[0],sbuf2[1],sbuf2[4],sbuf2[3],sbuf2[2]); 
3267   1         iputs0(stemp); 
3268   1       
3269   1         
3270   1         if(sbuf2[0]==1)
3271   1         {
3272   2            flg_voicemode = sbuf2[1];
3273   2            
3274   2            //ibtvol        = sbuf2[2];         //--keep
3275   2            ibtvol        = BTVOLSTART;
3276   2            
3277   2            inoisebasevol = sbuf2[3];   
3278   2            WN_MODE       = sbuf2[4];  
3279   2                  
3280   2         }
3281   1         else
3282   1         { 
3283   2            flg_voicemode = 0;      
3284   2            ibtvol = BTVOLSTART;      
3285   2            inoisebasevol = NOISEBASEVOLSTART;      
3286   2            WN_MODE =1;
3287   2         }   
3288   1         
3289   1         inoisevolume=get_noisevolume(WN_MODE);
3290   1         sprintf(stemp,"mode: %bu,%bu,%bu\r\n",WN_MODE,inoisebasevol,inoisevolume );
3291   1         iputs0(stemp);
3292   1         Switch_Delay1ms(20);
3293   1      
3294   1      
3295   1         //i2c data check
3296   1         if(flg_voicemode>1)
3297   1            flg_voicemode =0;   
3298   1         if(inoisebasevol > NOISEBASEVOLTOP)
3299   1            inoisebasevol =NOISEBASEVOLSTART;   
3300   1         if( (WN_MODE ==0) || (WN_MODE >6) )
3301   1            WN_MODE = 1;   
3302   1       
3303   1         
3304   1         flg_standby =1;
3305   1         flg_reset =0;
3306   1         
3307   1         
3308   1         //test
3309   1         flg_voicemode =1;
3310   1         WN_MODE =1;
3311   1         inoisebasevol =0;
3312   1         
3313   1         
3314   1         whitenoise_switch();
3315   1         
3316   1         if(flg_voicemode==0)
3317   1            flg_stopsendpair =0;
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 55  

3318   1         else
3319   1            flg_stopsendpair =1;
3320   1         
3321   1         
3322   1      #ifdef SNOOZBABY   
                 flg_voicemode =1;   
              #endif   
3325   1      
3326   1      
3327   1         while(1)
3328   1         {
3329   2            
3330   2            //static UINT32 imaincount =0;  
3331   2            static UINT8 flg_pairfirst =0;     
3332   2            
3333   2                  
3334   2            //powerkey scan
3335   2            powerkey_scan();      
3336   2      
3337   2            //powerkey check
3338   2            powerkey_check();  
3339   2            
3340   2            //dowith power key  
3341   2            powerkey_process();    
3342   2      
3343   2          
3344   2            
3345   2            if(flg_standby ==1)
3346   2            {
3347   3               P01 =0;
3348   3               P16 =1;   
3349   3            }      
3350   2            else
3351   2            {   
3352   3            
3353   3               if(flg_voicemode==0)
3354   3               {
3355   4               
3356   4                  if(P02)   //pairing
3357   4                  {
3358   5                     static UINT32 ipairledcount =0;
3359   5                     static UINT32 ipairtonecount =0;
3360   5                     
3361   5          
3362   5                     if (ipairledcount++>PAIR_LEDCOUNT)
3363   5                     {
3364   6                        ipairledcount =0;
3365   6                        P01 = ~P01;                  
3366   6                     }            
3367   5                     
3368   5                     ipairtonecount++;
3369   5                     
3370   5                     if( flg_pairfirst ==0  )
3371   5                     {
3372   6                        
3373   6                        if (ipairtonecount>5)
3374   6                        {
3375   7                           ipairtonecount =0;    
3376   7                           
3377   7                           flg_pairfirst =1;
3378   7                           
3379   7                           if( flg_stopsendpair ==0) 
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 56  

3380   7                           {
3381   8                              flg_pairing =1; ipairingcount =0;
3382   8                              
3383   8                              iputbytes0(spairingvoice,5);                  
3384   8                              Switch_Delay1ms(10); 
3385   8                           }   
3386   7                        }                  
3387   6                     }
3388   5                     else if (ipairtonecount>PAIR_TONECOUNT)
3389   5                     {
3390   6                        ipairtonecount =0;                       
3391   6      
3392   6                        if(flg_stopsendpair ==0) 
3393   6                        {
3394   7                           flg_pairing=1; ipairingcount =0;
3395   7                           
3396   7                           iputbytes0(spairingvoice,5);                  
3397   7                           Switch_Delay1ms(10); 
3398   7                        }                     
3399   6                     }            
3400   5                     
3401   5                     P16=0;  
3402   5                  }
3403   4                  else
3404   4                  {
3405   5                     P01 =0;   //pair  led   
3406   5                     P16 =1;   //charge led
3407   5                     
3408   5                     flg_pairfirst=0;
3409   5                  }
3410   4                  
3411   4               }
3412   3               else
3413   3               {
3414   4                  P01 =0;
3415   4                  P16 =1;
3416   4               }      
3417   3               
3418   3               
3419   3      //         if(imaincount++>=300)
3420   3      //         {
3421   3      //            imaincount =0;
3422   3      //            
3423   3      //            sprintf(stemp,"mode: %bu,%bu,%bu\r\n",WN_MODE,inoisebasevol,inoisevolume );
3424   3      //            //--iputs0(stemp);
3425   3      //            Switch_Delay1ms(20); 
3426   3      //         }
3427   3               
3428   3      
3429   3      //         if(imaincount++>=50)
3430   3      //         {
3431   3      //            imaincount =0;  
3432   3      //            
3433   3      //            sprintf(stemp,"p,c,s,a: %bu,%d,%bu,%bu\r\n",flg_pairing,ipairingcount,flg_stopsendpair,flg_s
             -witchaux );
3434   3      //            iputs0(stemp);
3435   3      //            Switch_Delay1ms(20);       
3436   3      //           
3437   3      //         }         
3438   3               
3439   3               
3440   3               //get adc
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 57  

3441   3               getadcvalue();   
3442   3               
3443   3      
3444   3               //adc key scan
3445   3               adckey_scan();   
3446   3               
3447   3               
3448   3               //P0f =~P0f;    //--timer line
3449   3               
3450   3               //adc key check         
3451   3               adckey_check();     
3452   3      
3453   3               //adc key process
3454   3               adckey_process( );   
3455   3               
3456   3               
3457   3               if( (flg_switchaux==1) || (ikeynum3 >0) )
3458   3               {
3459   4                  flg_stopsendpair =1;             
3460   4                  
3461   4                  //if(flg_switchaux==1) 
3462   4                  //   waitpairing();      
3463   4      
3464   4                  if(flg_switchaux==1) 
3465   4                  {
3466   5                    if (flg_pairing ==1) 
3467   5                        goto nextstep;
3468   5                     
3469   5                     flg_switchaux =0;         
3470   5                     switch2AUX(); 
3471   5                  }            
3472   4               }      
3473   3      
3474   3               if(ikeynum3==0)
3475   3               {
3476   4                  if(flg_voicemode==0)
3477   4                     flg_stopsendpair =0;
3478   4                  else
3479   4                     flg_stopsendpair =1;
3480   4               }            
3481   3         
3482   3               
3483   3      nextstep:
3484   3               if(flg_pairing ==1)
3485   3               {         
3486   4                  ipairingcount++; 
3487   4                  
3488   4                  if(ipairingcount >=PAIR_SWITHCOUNT)
3489   4                  {
3490   5                     ipairingcount =0;
3491   5                     flg_pairing=0;
3492   5                  }
3493   4               }          
3494   3              
3495   3            }      
3496   2            
3497   2         }
3498   1      
3499   1      }
3500          
3501          
3502          
C51 COMPILER V9.56.0.0   SNOOZ                                                             11/06/2019 15:37:16 PAGE 58  

3503          
3504          
3505          
3506          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9329    ----
   CONSTANT SIZE    =    326    ----
   XDATA SIZE       =    277     417
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
