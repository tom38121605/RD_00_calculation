C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE SNOOZ
OBJECT MODULE PLACED IN .\Objects\SNOOZ.obj
COMPILER INVOKED BY: C:\Keil_c51\C51\BIN\C51.EXE SNOOZ.c LARGE OPTIMIZE(3,SPEED) BROWSE INCDIR(..\..\Include) DEFINE(FOS
                    -C_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\SNOOZ.lst) TABS(3) OBJECT(.\Objects\SNOOZ.obj)

line level    source

   1          
   2          #include "N76E003.h"
   3          #include "Common.h"
   4          #include "Delay.h"
   5          #include "SFR_Macro.h"
   6          #include "Function_define.h"
   7          
   8          
   9          //white noise
  10          
  11          //#define NOISEVOLUMETOP 16
  12          #define NOISEVOLUMETOP 20
  13          
  14          UINT8 flg_newnoise = 0; 
  15          UINT8 inoisevolume =0;
  16          UINT8 inoisevolume_top = 0;
  17          
  18          
  19          //key 
  20          
  21          //#define LONGKEYCOUNT2_PWM0     75     //3.6s
  22          //#define LONGKEYCOUNT2_PWM1_6     150    //3.6s
  23          //#define LONGKEYCOUNT2_NOPWM      180    //3.6s
  24          
  25          //UINT32 LONGKEYCOUNT2 = 150;    //fixed 3.0s+ 
  26          UINT32 LONGKEYCOUNT2 = 90;    
  27          
  28          
  29          UINT8 flg_keydown1 =0;
  30          UINT8 flg_keydown2 =0;
  31          UINT8 flg_keydown3 =0;
  32          
  33          UINT8 ikeyvalue1 =0;
  34          UINT8 ikeyvalue2 =0;
  35          UINT8 ikeyvalue3 =0;
  36          
  37          UINT32 ikeynum1 =0;
  38          UINT32 ikeynum2 =0;
  39          UINT32 ikeynum3 =0;
  40          
  41          UINT8 flg_keycome1 =0;
  42          UINT8 flg_keycome2 =0;
  43          UINT8 flg_keycome3 =0;
  44          
  45           
  46          UINT8 flg_keydown10 =0;
  47          UINT8 flg_keyvalue10 =0;
  48          UINT8 flg_power =0;
  49          
  50          #define ADC_VOL_GAP                   200   
  51          
  52          #define ADC_VOLDEC                    (1200 - ADC_VOL_GAP)
  53          #define ADC_VOLADD                    (1750 - ADC_VOL_GAP)   
  54          #define ADC_TONE                      (2075 - ADC_VOL_GAP)   //建议改成1k电阻，这里为2242  -> 2250
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 2   

  55          
  56          #define ADC_VOL_NC                  300   //(ADC_VOL_L  - ADC_VOL_GAP)    
  57          #define ADC_VOL_NC2                 3000  //(ADC_VOL_UP + ADC_VOL_GAP)    
  58          
  59          
  60          //pwm
  61          
  62          UINT8  flg_openpwm =0;
  63          //UINT32 ipwmcount = 0;
  64          UINT8 ipwm_mode=0;
  65          
  66          
  67          //#define TIMER1_RELOAD_VALUE     84
  68          //#define PWM_PERIOD    0x1ff
  69          
  70          
  71          static S16 Harm_Val = 0x00;      // State for harmonic generator
  72          static UINT16 LFSR = 0xff;       // Any non-zero value will work as the seed
  73          static S16 LPF, L_OUT, S_OUT, LSB = 0x100;
  74          static U8   CTR_DIR = 0; 
  75          static U8   FN_MODE = 1;
  76          static U8   WN_MODE = 1;
  77          
  78          
  79          //static U8 LPF_K = 5;
  80          //static U8 HARM_K = 7;
  81          //static U8 NOISE_K = 7;
  82          //static U8 INCR = 16;
  83          
  84          
  85          static U8 LPF_K = 5;
  86          static U8 HARM_K = 7;
  87          static U8 NOISE_K = 1;
  88          static U8 INCR = 0;
  89          
  90          
  91          
  92          //BT command 
  93          
  94          UINT8 spoweron[5]  = {0xA5, 0x03, 0x84, 0x01, 0x2d};
  95          UINT8 spoweroff[5] = {0xA5, 0x03, 0x84, 0x03, 0x2f};
  96          
  97          UINT8 splaypause[5] = {0xA5, 0x03, 0x82, 0x03, 0x2d};
  98          UINT8 svoladd[5]    = {0xA5, 0x03, 0x8b, 0x20, 0x53};
  99          UINT8 svoldec[5]    = {0xA5, 0x03, 0x8b, 0x21, 0x54};
 100          
 101          UINT8 spairing[6] =   {0xA5, 0x04, 0x82, 0x07, 0x01, 0x33}; 
 102          UINT8 sBTAUX_Switch[5] = {0xA5, 0x03, 0x8c, 0x20, 0x54};
 103          
 104          
 105          //UINT8 svoicemode[5]={ };
 106          UINT8 flg_voicemode =0;     //0 -- BT, 1 -- AUX
 107          
 108          
 109          //timer1
 110          
 111          UINT32 itimer1_count1=0;
 112          UINT32 itimer1_count2=0;
 113          
 114          
 115          //adc
 116          
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 3   

 117          UINT16 BAND_value=0;
 118          
 119          #define BAND_3300  1526  
 120          
 121          #define RESISTOR_UP_K     10
 122          #define RESISTOR_DOWN_K   15
 123           
 124          UINT16 iadcvalue=0;  
 125          UINT16 iadcvalue_out=0; 
 126          UINT16 iadcvalue_avr=0; 
 127          UINT16 iadcvalue_delay=0; 
 128          UINT8 iadccount=0;
 129          UINT8 flg_channel =0;
 130          UINT8 sadctemp1[20];
 131          UINT8 sadctemp2[20];
 132          UINT8 sadcstate[20];
 133          
 134          //double fadc_key=0;
 135          UINT16 iadc_key=0;
 136          
 137          
 138          
 139          void Switch_Delay1ms( UINT32 inum)
 140          {
 141   1         UINT32 itemp =0;
 142   1         
 143   1         if(flg_openpwm==0)
 144   1         {
 145   2            
 146   2            //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 147   2            
 148   2            itemp=inum;      
 149   2            Timer0_Delay1ms(itemp);
 150   2         }
 151   1         else
 152   1         {
 153   2            //LONGKEYCOUNT2 = LONGKEYCOUNT2_PWM;
 154   2            
 155   2            itemp=inum;      
 156   2            Timer0_Delay1ms(itemp);
 157   2         }
 158   1      }
 159          
 160          //void Switch_Delay1ms( UINT32 inum)   //keep
 161          //{
 162          //   UINT32 itemp =0;
 163          //   
 164          //   if(flg_openpwm==0)
 165          //   {    
 166          //      //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 167          //      //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 168          //      
 169          //      itemp=inum;
 170          //      Timer0_Delay1ms(itemp);
 171          //   }
 172          //   else
 173          //   {
 174          //      switch (ipwm_mode)
 175          //      {
 176          //         
 177          //         case 0: 
 178          
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 4   

 179          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_PWM;
 180          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_PWM;
 181          //         
 182          //               //itemp=inum>>3;
 183          //               itemp=inum;
 184          //               Timer0_Delay1ms(itemp); 
 185          //               break;          
 186          //         
 187          //         case 1: 
 188          
 189          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 190          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 191          //         
 192          //               itemp=inum;
 193          //               Timer0_Delay1ms(itemp); 
 194          //               break;         
 195          //         
 196          //         case 2: 
 197          
 198          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 199          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 200          //         
 201          //               itemp=inum;
 202          //               Timer0_Delay1ms(itemp); 
 203          //               break;         
 204          //         
 205          //         case 3: 
 206          
 207          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 208          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 209          //         
 210          //               itemp=inum;
 211          //               Timer0_Delay1ms(itemp); 
 212          //               break;    
 213          //         
 214          //         case 4: 
 215          //         
 216          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 217          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 218          
 219          //               itemp=inum;
 220          //               Timer0_Delay1ms(itemp); 
 221          //               break;    
 222          //         
 223          //         case 5: 
 224          
 225          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 226          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 227          //         
 228          //               itemp=inum;
 229          //               Timer0_Delay1ms(itemp); 
 230          //               break;    
 231          //         
 232          //         case 6: 
 233          
 234          //               //LONGKEYCOUNT1 = LONGKEYCOUNT1_NOPWM;
 235          //               //LONGKEYCOUNT2 = LONGKEYCOUNT2_NOPWM;
 236          //         
 237          //               itemp=inum;
 238          //               Timer0_Delay1ms(itemp); 
 239          //               break;    
 240          //         
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 5   

 241          //         default:          
 242          //         
 243          //               break;  
 244          //         
 245          //      }
 246          //      
 247          //   }
 248          //}
 249          
 250          
 251          void count_Delay_ms(UINT32 ms)  //16M
 252          {
 253   1         UINT32 j;
 254   1         
 255   1         while(ms--)
 256   1         {
 257   2            
 258   2            //for(j = 0; j<173; j++)   
 259   2            for(j = 0; j<76; j++)   
 260   2            {
 261   3               _nop_();
 262   3               _nop_();
 263   3               _nop_();
 264   3               _nop_();
 265   3            }
 266   2         }
 267   1         
 268   1      }
 269          
 270          #define UART_LOG 
 271          void iputs0(UINT8 *msg)
 272          {
 273   1         #ifdef UART_LOG   
 274   1         while(*msg)
 275   1             Send_Data_To_UART0(*msg++);
 276   1         
 277   1         #endif
 278   1      }
 279          
 280          void iputs0B(UINT8 *msg)
 281          {
 282   1         while(*msg)
 283   1             Send_Data_To_UART0(*msg++);
 284   1      }
 285          
 286          
 287          void iputbytes0(UINT8 *msg, UINT32 ilen)
 288          {
 289   1         while(ilen--)
 290   1             Send_Data_To_UART0(*msg++);
 291   1      }
 292          
 293          #define     CFG_READ            0xC0
 294          #define     CFG_ERASE           0xE2
 295          #define     CFG_BYTE_PROGRAM    0xE1 
 296          void Enable_WDT_Reset_Config(void)
 297          {
 298   1         set_IAPEN;
 299   1         set_CFUEN;
 300   1         
 301   1         IAPAL = 0x04;
 302   1         IAPAH = 0x00;
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 6   

 303   1         IAPFD = 0x0F;
 304   1         IAPCN = CFG_BYTE_PROGRAM;
 305   1         set_IAPGO;  
 306   1         
 307   1         //trigger IAP
 308   1         while((CHPCON&SET_BIT6)==SET_BIT6);          //check IAPFF (CHPCON.6)
 309   1         
 310   1         clr_CFUEN;
 311   1         clr_IAPEN;
 312   1            
 313   1      }
 314          
 315          double  Bandgap_Voltage;
 316          void READ_BANDGAP(void)
 317          {
 318   1            UINT8 BandgapHigh,BandgapLow,BandgapMark;
 319   1            double Bandgap_Value,Bandgap_Voltage_Temp;
 320   1      
 321   1            set_IAPEN;
 322   1            IAPCN = READ_UID;
 323   1            IAPAL = 0x0d;
 324   1            IAPAH = 0x00;
 325   1            set_IAPGO;
 326   1            BandgapLow = IAPFD;
 327   1            BandgapMark = BandgapLow&0xF0;
 328   1               
 329   1            if (BandgapMark==0x80)
 330   1            {
 331   2                  BandgapLow = BandgapLow&0x0F;
 332   2                  IAPAL = 0x0C;
 333   2                  IAPAH = 0x00;
 334   2                  set_IAPGO;
 335   2                  BandgapHigh = IAPFD;
 336   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 337   2                  Bandgap_Voltage_Temp = Bandgap_Value*3/4;
 338   2                  Bandgap_Voltage = Bandgap_Voltage_Temp - 33;       //the actually banggap voltage value is similar this va
             -lue.
 339   2            }
 340   1            if (BandgapMark==0x00)
 341   1            {
 342   2                  BandgapLow = BandgapLow&0x0F;
 343   2                  IAPAL = 0x0C;
 344   2                  IAPAH = 0x00;
 345   2                  set_IAPGO;
 346   2                  BandgapHigh = IAPFD;
 347   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 348   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 349   2            }
 350   1            if (BandgapMark==0x90)
 351   1            {
 352   2                  IAPAL = 0x0E;
 353   2                  IAPAH = 0x00;
 354   2                  set_IAPGO;
 355   2                  BandgapHigh = IAPFD;
 356   2                  IAPAL = 0x0F;
 357   2                  IAPAH = 0x00;
 358   2                  set_IAPGO;
 359   2                  BandgapLow = IAPFD;
 360   2                  BandgapLow = BandgapLow&0x0F;
 361   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 362   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 363   2            }
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 7   

 364   1            clr_IAPEN;
 365   1            
 366   1      //       printf ("\n BG High = %bX",BandgapHigh); 
 367   1      //       printf ("\n BG Low = %bX",BandgapLow); 
 368   1      //       printf ("\n BG ROMMAP = %e",Bandgap_Voltage); 
 369   1            
 370   1      }
 371          
 372          
 373          UINT8 get_checksum_8(UINT8 *ival, UINT32 inum)
 374          {
 375   1         UINT32 i =0;
 376   1         UINT8 iret =0;
 377   1         UINT16 isum =0;
 378   1         
 379   1         for (i=0; i<inum; i++)
 380   1         {
 381   2            isum += ival[i];      
 382   2         }
 383   1         
 384   1         iret = (UINT8)(isum & 0xff);
 385   1         
 386   1         return iret;
 387   1         
 388   1      }
 389          
 390          
 391          void set_realvolume(UINT8 ivol)
 392          {
 393   1         UINT8 icmd[5]={0xa5, 0x03, 0x8b, 0, 0 };
 394   1         
 395   1         icmd[3] = ivol;
 396   1         icmd[4] = get_checksum_8(icmd,4); 
 397   1         
 398   1         iputbytes0(icmd,5);
 399   1         
 400   1      }
 401          
 402          
 403          
 404          void set_volume(UINT8 ivol)
 405          {
 406   1         UINT8 icmd[5]={0xa5, 0x03, 0x8b, 0, 0 };
 407   1         
 408   1         if(ivol >10)
 409   1            ivol =10;
 410   1         
 411   1         switch (ivol)
 412   1         {
 413   2            case 0:
 414   2               
 415   2               icmd[3] = 0;
 416   2               break;
 417   2            
 418   2            case 1:
 419   2               
 420   2               icmd[3] = 4;
 421   2               break;
 422   2            
 423   2            case 2:
 424   2            case 3:
 425   2            case 4:
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 8   

 426   2            case 5:
 427   2            case 6:
 428   2            case 7:
 429   2            case 8:
 430   2            case 9:
 431   2            case 10:
 432   2               
 433   2               icmd[3] = 4 + (ivol-1) *3 ;
 434   2               break;      
 435   2             
 436   2            default:
 437   2      
 438   2               break;
 439   2            
 440   2         }
 441   1         icmd[4] = get_checksum_8(icmd,4); 
 442   1         
 443   1         iputbytes0(icmd,5);   
 444   1      }
 445          
 446          
 447          
 448          //void getadcvalue (UINT8 icomindex) 
 449          //{  
 450          //   UINT8 stemp2[20]={0}; 
 451          //   UINT16 AIN_value=0;
 452          //   double iadc =0;
 453          //   
 454          //   
 455          //   //-------------BAND-----------------
 456          //   
 457          //   Enable_ADC_BandGap;     
 458          //   CKDIV = 0x02;   
 459          
 460          //   
 461          //   clr_ADCF;
 462          //   set_ADCS;                             
 463          //   while(ADCF == 0);  
 464          
 465          //   BAND_value =  ADCRH ;
 466          //   BAND_value <<=  4 ;
 467          //   BAND_value |=  ADCRL & 0x0f ;      
 468          
 469          //   CKDIV = 0;   
 470          //   Disable_ADC;      
 471          //      
 472          //   switch (icomindex)
 473          //   {  
 474          //     
 475          //      case 0:      
 476          //         
 477          //         //-------------AIN5-----------------
 478          //         
 479          //         Enable_ADC_AIN5;       
 480          //         
 481          //         clr_ADCF;
 482          //         set_ADCS;                    
 483          
 484          //         while(ADCF == 0);
 485          //         
 486          //         AIN_value =  ADCRH ;
 487          //         AIN_value <<=  4 ;
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 9   

 488          //         AIN_value |=  ADCRL & 0x0f ;      
 489          //         
 490          //         iadc =   Bandgap_Voltage * AIN_value  / BAND_value;  //mv        
 491          //         iadcvalue = (UINT16)iadc;
 492          //      
 493          //      
 494          //         //iadcvalue_out = ( (INT16) (iadcvalue -  iadcvalue_delay) >>AVRBITCOUNT ) + iadcvalue_delay;
 495          //         //iadcvalue_delay = iadcvalue_out; 
 496          //      
 497          
 498          //         flg_channel=1;
 499          //       
 500          //         Disable_ADC;
 501          //         
 502          //         break;
 503          //      
 504          //         
 505          //      default:
 506          
 507          //         break;
 508          //      
 509          //  }   
 510          //   
 511          //}
 512          
 513          
 514          void getadcvalue () 
 515          {  
 516   1         UINT8 stemp2[20]={0}; 
 517   1         UINT16 AIN_value=0;
 518   1         double iadc =0;
 519   1         
 520   1         
 521   1         //-------------BAND-----------------
 522   1         
 523   1         Enable_ADC_BandGap;    
 524   1         //CKDIV = 0x02;   
 525   1      
 526   1         
 527   1         clr_ADCF;
 528   1         set_ADCS;                               
 529   1         while(ADCF == 0);  
 530   1      
 531   1         BAND_value =  ADCRH ;
 532   1         BAND_value <<=  4 ;
 533   1         BAND_value |=  ADCRL & 0x0f ;      
 534   1      
 535   1         //CKDIV = 0;   
 536   1         Disable_ADC;      
 537   1            
 538   1       
 539   1         //-------------AIN5-----------------
 540   1         
 541   1         Enable_ADC_AIN5;      
 542   1         
 543   1         clr_ADCF;
 544   1         set_ADCS;                      
 545   1      
 546   1         while(ADCF == 0);
 547   1         
 548   1         AIN_value =  ADCRH ;
 549   1         AIN_value <<=  4 ;
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 10  

 550   1         AIN_value |=  ADCRL & 0x0f ;      
 551   1         
 552   1         //iadc =   Bandgap_Voltage * AIN_value  / BAND_value;     //mv        
 553   1         iadc =   Bandgap_Voltage * AIN_value  /  BAND_3300;     //mv        
 554   1         iadcvalue = (UINT16)iadc;
 555   1      
 556   1      
 557   1         //iadcvalue_out = ( (INT16) (iadcvalue -  iadcvalue_delay) >>AVRBITCOUNT ) + iadcvalue_delay;
 558   1         //iadcvalue_delay = iadcvalue_out; 
 559   1      
 560   1         flg_channel=1;
 561   1       
 562   1         Disable_ADC;      
 563   1         
 564   1      }
 565          
 566          
 567          //#define TIMER_DIV12_COUNT_10ms       65536-13334 
 568          //#define TIMER_DIV12_COUNT_3ms           65536-4000
 569          //#define TIMER_DIV12_COUNT_2ms           65536-2667
 570          //#define TIMER_DIV12_COUNT_1ms           65536-1334
 571          //#define TIMER_DIV12_COUNT_500us         65536-667
 572          //#define TIMER_DIV12_COUNT_100us         65536-133
 573          //#define TIMER_DIV12_COUNT_50us       65536-67
 574          
 575          
 576          //#define TIMER_DIV12_COUNT  TIMER_DIV12_COUNT_1ms 
 577          
 578          //void Timer1_ISR (void) interrupt 3 
 579          //{   
 580          //   static UINT8 iscanindex =0;  
 581          
 582          //   itimer1_count1++;     
 583          //   itimer1_count2++;     
 584          //   //itimer1_count3++;     
 585          //   
 586          
 587          //   TL1 = TIMER_DIV12_COUNT & 0xFF;       
 588          //   TH1 = TIMER_DIV12_COUNT >> 8 ;    
 589          
 590          //   
 591          //   //getadcvalue(iscanindex);   
 592          //   getadcvalue();   
 593          //   
 594          //   
 595          //   iscanindex=0;
 596          //   //if(iscanindex<4)
 597          //   //   iscanindex++;
 598          //   //else
 599          //   //   iscanindex=0;   
 600          //   
 601          //}
 602          
 603          //void timer1_init (void)
 604          //{
 605          //   
 606          //   TIMER1_MODE1_ENABLE;
 607          
 608          //   clr_T1M;      //  sysclk/12   
 609          //   //set_T1M;      //  sysclk
 610          
 611          //   TL1 = TIMER_DIV12_COUNT & 0xff;       
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 11  

 612          //   TH1 = TIMER_DIV12_COUNT >> 8 ; 
 613          //   
 614          
 615          //   set_ET1;                                    
 616          //   set_EA;                                     
 617          
 618          //   set_TR1;     //Timer1 run
 619          //   
 620          //}
 621          
 622          
 623          static void Modify_HIRC_Value(void)      
 624          {
 625   1         bit BIT_TMP;
 626   1         unsigned char hircmap0,hircmap1;
 627   1         unsigned int trimvalue16bit;
 628   1         set_IAPEN;
 629   1         IAPAL = 0x30;
 630   1         IAPAH = 0x00;
 631   1         IAPCN = 0X04;
 632   1         set_IAPGO;
 633   1         hircmap0 = IAPFD;
 634   1         IAPAL = 0x31;
 635   1         IAPAH = 0x00;
 636   1         set_IAPGO;
 637   1         hircmap1 = IAPFD;
 638   1         clr_IAPEN;
 639   1         trimvalue16bit = ((hircmap0<<1)+(hircmap1&0x01));
 640   1         trimvalue16bit = trimvalue16bit - 15;
 641   1         hircmap1 = trimvalue16bit&0x01;
 642   1         hircmap0 = trimvalue16bit>>1;
 643   1         TA=0XAA;
 644   1         TA=0X55;
 645   1         RCTRIM0 = hircmap0;
 646   1         TA=0XAA;
 647   1         TA=0X55;
 648   1         RCTRIM1 = hircmap1;
 649   1      
 650   1      }
 651          
 652          void pwm_init(void)
 653          {  
 654   1         
 655   1         // set up IO
 656   1         P05_PushPull_Mode;
 657   1         
 658   1         //set up PWM2, this will be the noise source DAC
 659   1         PWM2_P05_OUTPUT_ENABLE;
 660   1         PWM_INT_PWM2;   
 661   1         PWM_FALLING_INT;                   //Setting Interrupt happen when PWM0 falling signal
 662   1      
 663   1         PWM_CLOCK_DIV_2;
 664   1         PWMPH = 0x01;                     //Setting PWM period
 665   1         PWMPL = 0xFF;
 666   1         
 667   1         PWM2H = 0x00;                     //PWM2, duty = 1/2 PWM period
 668   1         PWM2L = 0xFF;   
 669   1         
 670   1         //set priority  3
 671   1         EIP  |= (1<<3);   
 672   1         EIPH |= (1<<3);       
 673   1      
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 12  

 674   1         set_EPWM;                         //Enable PWM interrupt
 675   1         set_EA;                           
 676   1         set_LOAD;
 677   1         //set_PWMRUN;
 678   1      
 679   1      }  
 680          
 681          
 682          void PWM_ISR (void) interrupt 13
 683          {
 684   1         clr_PWMF;                                                 // clear the interrupt flag   
 685   1         //P02 = 1;                                                  // just an I/O marker to show activity   
 686   1        
 687   1         // Harmonics generator   
 688   1         if(CTR_DIR)
 689   1         {
 690   2            Harm_Val = (Harm_Val + INCR);
 691   2            if (Harm_Val >= 0x1FE)                                 // ramped to max?
 692   2            {   
 693   3               Harm_Val = 0x1FE;
 694   3               CTR_DIR = 0;
 695   3            }
 696   2         }
 697   1         else
 698   1         {
 699   2            Harm_Val = (Harm_Val - INCR);
 700   2            if (Harm_Val <= 0x0)                                    // ramped to zero?
 701   2            {
 702   3               Harm_Val = 1;
 703   3               CTR_DIR = 1;   
 704   3            }
 705   2         }
 706   1      
 707   1         // White noise generator (Galois LFSR)
 708   1         LSB = LFSR & 0x01u;                                         // Get LSB (i.e., the output bit)
 709   1         LFSR = (UINT16)LFSR >> 1;                                   // Shift register 
 710   1         if (LSB)                                                    // If the output bit is 1, 
 711   1               LFSR ^= 0xB400u;                                      // Apply polynomial feedback. 
 712   1                  
 713   1         // Sum the noise and harmonics and apply the gain
 714   1         L_OUT = (S16)(((LFSR >> (NOISE_K + 7u))));               // kN . N
 715   1         S_OUT = (S16)((Harm_Val >> HARM_K));                     // kH . H
 716   1         L_OUT = (S16)(L_OUT + S_OUT);                            // kH.H + kN.N
 717   1      
 718   1         // Low Pass Filter (1st order IIR) 
 719   1         L_OUT = (S16)(L_OUT - LPF);                              // x[n] - y[n-1]//
 720   1         L_OUT = (S16)(L_OUT >> LPF_K);                           // k(x[n] - y[n-1])
 721   1         L_OUT = (S16)(L_OUT + LPF);                              // k(x[n] - y[n-1]) + y[n-1]
 722   1         LPF = L_OUT;                                             // y[n] => y[n-1]
 723   1         
 724   1               
 725   1         // set size and range of output data, exceeding range will crash the HW   
 726   1         L_OUT = (UINT16)(L_OUT & 0x1ff);
 727   1         if(L_OUT == 0)
 728   1            L_OUT = 0x0001;
 729   1         if(L_OUT == 0x01ff)
 730   1            L_OUT = 0x01fe;      
 731   1                  
 732   1         // DAC output            
 733   1         PWM2H = (UINT16)(L_OUT >> 8) & 0x01;               // high byte   
 734   1         PWM2L = L_OUT & 0xff;                              // low byte
 735   1         set_LOAD;                                          // latch the updated PWM value to the PWM engine
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 13  

 736   1         
 737   1         //P02 = 0;                                           // just an I/O marker to show activity
 738   1                 
 739   1      }
 740          
 741          //white noise switch
 742          void whitenoise_switch(void)
 743          {
 744   1       
 745   1         switch(WN_MODE)
 746   1         {
 747   2            
 748   2            //from WN_MODE
 749   2            case 1:
 750   2            {
 751   3               LPF_K = 5;
 752   3               HARM_K = 7;
 753   3               NOISE_K = 1;
 754   3               INCR = 0;      
 755   3               break;                     
 756   3            }
 757   2            case 2:
 758   2            {
 759   3               LPF_K = 3;
 760   3               HARM_K = 7;
 761   3               NOISE_K = 2;
 762   3               INCR = 0;      
 763   3               break;                     
 764   3            }
 765   2            case 3:
 766   2            {
 767   3               LPF_K = 1;
 768   3               HARM_K = 7;
 769   3               NOISE_K = 3;
 770   3               INCR = 0;      
 771   3               break;                     
 772   3            }
 773   2            
 774   2            
 775   2            //from FN_MODE
 776   2            case 4:
 777   2            {
 778   3               LPF_K = 6;
 779   3               HARM_K = 1;
 780   3               NOISE_K = 1;
 781   3               INCR = 5;      
 782   3               break;                     
 783   3            }
 784   2            case 5:
 785   2            {
 786   3               LPF_K = 4;
 787   3               HARM_K = 3;
 788   3               NOISE_K = 2;
 789   3               INCR = 6;      
 790   3               break;                     
 791   3            }
 792   2            case 6:
 793   2            {
 794   3               LPF_K = 2;
 795   3               HARM_K = 4;
 796   3               NOISE_K = 3;
 797   3               INCR = 7;      
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 14  

 798   3               break;                     
 799   3            }           
 800   2            
 801   2         }
 802   1       
 803   1               
 804   1      }  
 805          
 806          void get_volumetop(UINT8 imode)
 807          {
 808   1      
 809   1            switch (imode)
 810   1            {
 811   2               
 812   2               case 1: 
 813   2                  inoisevolume_top = NOISEVOLUMETOP +5+5;  
 814   2                  break;
 815   2               
 816   2               case 2: 
 817   2                  inoisevolume_top = NOISEVOLUMETOP +3;   
 818   2                  break;
 819   2               
 820   2               case 3: 
 821   2                  inoisevolume_top = NOISEVOLUMETOP +1 +8;   
 822   2                  break;
 823   2               
 824   2               case 4: 
 825   2                  inoisevolume_top = NOISEVOLUMETOP +5+3;   
 826   2                  break;
 827   2               
 828   2               case 5: 
 829   2                  inoisevolume_top = NOISEVOLUMETOP +5;   
 830   2                  break;
 831   2               
 832   2               case 6: 
 833   2                  inoisevolume_top = NOISEVOLUMETOP +6;  
 834   2                  break;
 835   2               
 836   2               default: 
 837   2      
 838   2                  break;               
 839   2               
 840   2            }  
 841   1                  
 842   1      }
 843          
 844          void powerkey_scan(void)
 845          {
 846   1         
 847   1            if( P15  && (flg_keydown10==0) )
 848   1            {
 849   2               
 850   2               Switch_Delay1ms(10); 
 851   2               
 852   2      
 853   2               if(P15)   
 854   2               {            
 855   3                  flg_keydown10=1; 
 856   3                  flg_keyvalue10=1;            
 857   3               }
 858   2               
 859   2            }
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 15  

 860   1            else if(!P15)
 861   1            {
 862   2      
 863   2               Switch_Delay1ms(10); 
 864   2      
 865   2      
 866   2               if(!P15)               
 867   2                  flg_keydown10 = 0;  
 868   2            }   
 869   1         
 870   1      }
 871          
 872          void powerkey_process(void)
 873          {
 874   1         
 875   1            if(flg_keyvalue10==1)
 876   1            {
 877   2               flg_keyvalue10=0;
 878   2               
 879   2               iputs0("power key in\r\n");
 880   2               
 881   2               if(flg_power==0)
 882   2               { 
 883   3                  
 884   3                  //open power
 885   3                  P03=1; 
 886   3                  flg_power=1;
 887   3                  Switch_Delay1ms(100);            
 888   3                  
 889   3                  P12=1;   //led
 890   3                  
 891   3                  
 892   3                  //onoff start level
 893   3                  P10=1;   
 894   3                  Switch_Delay1ms(2000);  
 895   3                  P10=0;  
 896   3                  Switch_Delay1ms(100);     
 897   3                  
 898   3        
 899   3                  //open AMP   --normal
 900   3                  P11=1; 
 901   3                  Switch_Delay1ms(1000);        
 902   3                  
 903   3                  iputbytes0(spoweron,5);
 904   3                  Switch_Delay1ms(10);   
 905   3                  
 906   3                  
 907   3      //            //open AMP    //--test
 908   3      //            //Switch_Delay1ms(7000);            
 909   3      //            Switch_Delay1ms(1000);            
 910   3      //            P11=1; 
 911   3                  
 912   3      
 913   3                  //wait connected 
 914   3                  //while ( (flg_connected==1) && (iconncount>=1000) ) iconncount++;
 915   3                  set_realvolume(5); 
 916   3                  Switch_Delay1ms(10);               
 917   3                  
 918   3               }            
 919   2               else
 920   2               {
 921   3      
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 16  

 922   3                  Switch_Delay1ms(1000);
 923   3      
 924   3                  iputbytes0(spoweroff,5);
 925   3                  Switch_Delay1ms(10);
 926   3      
 927   3                  Switch_Delay1ms(3500);
 928   3                  
 929   3                  P11=0; 
 930   3                  Switch_Delay1ms(100);
 931   3                  
 932   3              
 933   3                  //P12=0;   //led    
 934   3                  
 935   3                  P03=0;
 936   3                  flg_power=0;   
 937   3                  
 938   3                  
 939   3                  //close pwm
 940   3                  //clr_PWMRUN;
 941   3                  //flg_openpwm =0
 942   3                  
 943   3               }         
 944   2               
 945   2            }   
 946   1            
 947   1      }
 948          
 949          void adckey_scan(void)
 950          {
 951   1            
 952   1            if(flg_channel==1)
 953   1            {
 954   2               flg_channel=0;    
 955   2      
 956   2               //iputs0("adc scan...\r\n");   
 957   2               
 958   2              
 959   2               //iadc_key = (UINT16)((double)BAND_value / BAND_3300 * iadcvalue);  
 960   2               iadc_key= iadcvalue;
 961   2               
 962   2               //sprintf( sadctemp1, "adckey: %u\r\n", iadc_key);     
 963   2               //sprintf( sadctemp2, "BanD:%u,adc:%u\r\n", BAND_value,iadcvalue_avr); 
 964   2               
 965   2      
 966   2               if(iadc_key >= ADC_VOL_NC2 )
 967   2               {
 968   3      
 969   3                  Switch_Delay1ms(10); 
 970   3      
 971   3      
 972   3                  if(iadc_key >= ADC_VOL_NC2 )
 973   3                  {
 974   4                     //--if(KEY0_NC_PIN==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("no key2\r\n"); Switc
             -h_Delay1ms(2); }
 975   4                     //sprintf( sadcstate, "no key2\r\n");
 976   4                     
 977   4                     flg_keydown1 = 0;
 978   4                     flg_keydown2 = 0;
 979   4                     flg_keydown3 = 0;
 980   4                     
 981   4                  }               
 982   3               }         
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 17  

 983   2               
 984   2               else if (iadc_key >= ADC_TONE )
 985   2               {
 986   3               
 987   3                  Switch_Delay1ms(10); 
 988   3       
 989   3      
 990   3                  if(iadc_key >= ADC_TONE )
 991   3                  {
 992   4       
 993   4                     //if(flg_keydown3==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("tone key\r\n"); Swit
             -ch_Delay1ms(2); }               
 994   4                     //sprintf( sadcstate, "tone key\r\n");
 995   4      
 996   4                  
 997   4                     flg_keydown1 = 0;
 998   4                     flg_keydown2 = 0;
 999   4                     flg_keydown3 = 1;   
1000   4      
1001   4                     ikeyvalue3 = 1;               
1002   4                     
1003   4                  }               
1004   3               }
1005   2      
1006   2               else if (iadc_key >= ADC_VOLADD )
1007   2               {
1008   3      
1009   3                  Switch_Delay1ms(10);  
1010   3      
1011   3                  if(iadc_key >= ADC_VOLADD )
1012   3                  {
1013   4                     //if(flg_keydown2==0)  {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol+ key\r\n"); Swit
             -ch_Delay1ms(2); }
1014   4                     //sprintf( sadcstate, "vol+ key\r\n");
1015   4      
1016   4                     flg_keydown1 = 0;
1017   4                     flg_keydown2 = 1;
1018   4                     flg_keydown3 = 0;
1019   4                     
1020   4                     ikeyvalue2 = 1; 
1021   4                     
1022   4                  }               
1023   3               }     
1024   2               else if(iadc_key >= ADC_VOLDEC )
1025   2               {
1026   3                  
1027   3                  Switch_Delay1ms(10); 
1028   3      
1029   3                  if(iadc_key >= ADC_VOLDEC )
1030   3                  {
1031   4                     //if(flg_keydown1==0) {iputs0(sadctemp1); Switch_Delay1ms(2); iputs0("vol- key\r\n"); Switc
             -h_Delay1ms(2); }
1032   4                     //sprintf( sadcstate, "vol- key\r\n");
1033   4                     
1034   4                     flg_keydown1 = 1;
1035   4                     flg_keydown2 = 0;
1036   4                     flg_keydown3 = 0;
1037   4                     
1038   4                     ikeyvalue1 = 1; 
1039   4                     
1040   4                  }               
1041   3               }         
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 18  

1042   2                
1043   2            }   
1044   1         
1045   1      
1046   1      }
1047          
1048          //void adckey_check(void)
1049          //{
1050          //   static UINT8 flg_longkey=0;
1051          //   
1052          //   if (flg_keycome3==1) return;
1053          //   
1054          //   //key3 tone
1055          //   if (flg_keydown3) 
1056          //   {
1057          //      ikeynum3++;   
1058          //      
1059          //      if(ikeynum3>=LONGKEYCOUNT2)
1060          //         {ikeyvalue3 =2; flg_keycome3=1;} 
1061          //      
1062          //      //long key time test 
1063          //      if(flg_longkey==0)
1064          //      {
1065          //         P02=1;
1066          //      }
1067          //      
1068          //      if(ikeynum3>=LONGKEYCOUNT2)
1069          //      {
1070          //         P02=0;
1071          //         flg_longkey=1;
1072          //      }
1073          
1074          //   }         
1075          //   else
1076          //   {
1077          //      //long key time test 
1078          //      P02=0;
1079          //      flg_longkey=0;
1080          //      
1081          //      
1082          //      if (ikeynum3<1) 
1083          //          ikeyvalue3 =0;
1084          //      else if (ikeynum3<LONGKEYCOUNT2)
1085          //          {ikeyvalue3 =1; flg_keycome3=1;}    
1086          //      else          
1087          //          {ikeyvalue3 =2; flg_keycome3=1;}  
1088          //          
1089          //   } 
1090          //     
1091          //}   
1092          
1093          void adckey_check(void)
1094          {
1095   1         //static UINT8 flg_longkey=0;
1096   1         static UINT8 flg_downlongkey3=0;
1097   1         
1098   1         if (flg_downlongkey3==0) 
1099   1         {
1100   2         
1101   2            //key3 tone
1102   2            if (flg_keydown3) 
1103   2            {
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 19  

1104   3               ikeynum3++;   
1105   3               
1106   3               if(ikeynum3>=LONGKEYCOUNT2)
1107   3                  {ikeyvalue3 =2; flg_keycome3=1; flg_downlongkey3=1;} 
1108   3      
1109   3            }         
1110   2            else
1111   2            {
1112   3               
1113   3               if (ikeynum3<1) 
1114   3                   ikeyvalue3 =0;
1115   3               else if (ikeynum3<LONGKEYCOUNT2)
1116   3                   {ikeyvalue3 =1; flg_keycome3=1;}    
1117   3               else          
1118   3                   {ikeyvalue3 =2; flg_keycome3=1;}  
1119   3                   
1120   3            } 
1121   2            
1122   2         }
1123   1         else
1124   1         {
1125   2      
1126   2            if (flg_keydown3==0) 
1127   2            {                 
1128   3               flg_downlongkey3=0; 
1129   3               ikeynum3=0; ikeyvalue3=0;    
1130   3            }       
1131   2            
1132   2         }
1133   1         
1134   1         
1135   1               
1136   1      }   
1137          
1138          
1139          void adckey_process(void)
1140          {
1141   1         UINT8 stemp[20]={0};
1142   1         
1143   1         //key1  vol-
1144   1         if( (ikeyvalue1==1) && (flg_keydown1==0) )
1145   1         {
1146   2            ikeyvalue1=0;
1147   2            
1148   2            iputbytes0(svoldec,5);      
1149   2            //set_volume(3);
1150   2            
1151   2            Switch_Delay1ms(10);       
1152   2            
1153   2         }
1154   1      
1155   1         
1156   1         //key2  vol+
1157   1         if( (ikeyvalue2==1) && (flg_keydown2==0) )
1158   1         {
1159   2            ikeyvalue2=0;
1160   2            
1161   2            iputbytes0(svoladd,5);   
1162   2            //set_volume(7);
1163   2            
1164   2            Switch_Delay1ms(10);       
1165   2            
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 20  

1166   2         }
1167   1         
1168   1         
1169   1         //key3 tone
1170   1         if  (flg_keycome3==1 )
1171   1         {
1172   2            flg_keycome3=0;
1173   2      
1174   2            if (ikeyvalue3 ==1)      //short 
1175   2            {
1176   3               
1177   3               if(flg_voicemode ==0)  //BT MODE
1178   3               {
1179   4                  iputbytes0(splaypause,5);
1180   4                  Switch_Delay1ms(10);
1181   4                  
1182   4                  ikeynum3=0; ikeyvalue3=0;
1183   4               }
1184   3               else if(flg_voicemode ==1)  //AUX MODE
1185   3               { 
1186   4                  
1187   4                  //get new noise mode
1188   4                  
1189   4                  //whitenoise_switch(); 
1190   4                  
1191   4                  WN_MODE++;
1192   4                  if(WN_MODE == 7)
1193   4                     WN_MODE = 1;  
1194   4      
1195   4      
1196   4                  get_volumetop(WN_MODE);
1197   4                  
1198   4                  flg_newnoise = 1;
1199   4                  
1200   4                  //mute
1201   4                  P11=0; 
1202   4                  Switch_Delay1ms(10);
1203   4                  
1204   4                  
1205   4                  whitenoise_switch(); 
1206   4                  
1207   4                  set_realvolume(inoisevolume_top);
1208   4                  Switch_Delay1ms(10);  
1209   4                  
1210   4                  
1211   4                  //unmute
1212   4                  Switch_Delay1ms(10);
1213   4                  P11=1; 
1214   4                  
1215   4                  
1216   4                  
1217   4                  //ipwm_mode=WN_MODE;  
1218   4                  
1219   4                  Switch_Delay1ms(100);  
1220   4                  sprintf(stemp,"mode: %bu,%bu\r\n",WN_MODE,inoisevolume_top );
1221   4                  iputs0(stemp);
1222   4                  Switch_Delay1ms(20);  
1223   4      
1224   4                  
1225   4                  ikeynum3=0; ikeyvalue3=0;          
1226   4               }
1227   3               
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 21  

1228   3            }
1229   2      
1230   2            //switch BT and AUX 
1231   2            if (ikeyvalue3 ==2)   //long
1232   2            {
1233   3               
1234   3               //P12 = ~P12;
1235   3      
1236   3                 
1237   3               if(flg_voicemode==0)    //switch to AUX  
1238   3               {  
1239   4      
1240   4                  //send cmd 
1241   4                  iputbytes0(sBTAUX_Switch,5);
1242   4                  Switch_Delay1ms(10); 
1243   4      
1244   4                  Switch_Delay1ms(100);
1245   4                  get_volumetop(1);
1246   4                  set_realvolume(inoisevolume_top);            
1247   4                  Switch_Delay1ms(100);            
1248   4                  
1249   4      
1250   4                  set_PWMRUN;            
1251   4                  flg_openpwm =1;
1252   4                  
1253   4                  flg_voicemode =1;      //switch to AUX  
1254   4                  
1255   4                  P12=0;   //led      //--test     
1256   4                  
1257   4                  //inoisevolume_top = NOISEVOLUMETOP -5; //mode1
1258   4                  //set_realvolume(inoisevolume_top);
1259   4                  
1260   4               }
1261   3               else    //switch to BT  
1262   3               {
1263   4      
1264   4                  //send cmd 
1265   4                  iputbytes0(sBTAUX_Switch,5);
1266   4                  Switch_Delay1ms(10);            
1267   4                  
1268   4                  clr_PWMRUN;
1269   4                  flg_openpwm =0;            
1270   4                  
1271   4                  flg_voicemode =0;      //switch to BT  
1272   4                  
1273   4                  P12=1;                 //led   //--test    
1274   4                  
1275   4               } 
1276   3               
1277   3               ikeynum3=0; ikeyvalue3=0;
1278   3            }
1279   2             
1280   2         }    
1281   1      }
1282          
1283          
1284                   
1285          #define UARTDELAYTIMES 6
1286          void main (void)
1287          {
1288   1         UINT8 stemp[20]={0};    
1289   1         
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 22  

1290   1         
1291   1      //   P00_Input_Mode;    //USB DET
1292   1      //   P17_Input_Mode;    //CHARGE DONE
1293   1      //   P30_Input_Mode;    //BAT DET
1294   1         
1295   1         
1296   1         InitialUART0_Timer3(115200); 
1297   1         
1298   1         iputs0("start................\r\n"); 
1299   1         
1300   1         
1301   1         //set systemclock
1302   1         set_HIRCST;
1303   1         
1304   1      
1305   1         //adc bandgap
1306   1         READ_BANDGAP();   
1307   1         sprintf (stemp,"band vol = %6.2f\r\n",Bandgap_Voltage); 
1308   1         //--iputs0(stemp);    
1309   1      
1310   1      
1311   1         //main power     
1312   1         P15_Input_Mode;   
1313   1         P03_PushPull_Mode;   
1314   1         P03=0;   
1315   1      
1316   1      
1317   1         //BT ONOFF
1318   1         P10_PushPull_Mode;
1319   1         P10=0;
1320   1         
1321   1         
1322   1         //AMP CTRL
1323   1         P11_PushPull_Mode;
1324   1         P11=0;   
1325   1         
1326   1         
1327   1         //LED  test
1328   1         P12_PushPull_Mode;
1329   1         P12=1;     
1330   1      
1331   1      
1332   1         // test pin
1333   1      //   //P01_PushPull_Mode;
1334   1      //   //P01=0; 
1335   1      //   P16_PushPull_Mode;
1336   1      //   P16=0; 
1337   1         P02_PushPull_Mode;
1338   1         P02=0; 
1339   1       
1340   1         
1341   1         //pwm init
1342   1         pwm_init();   
1343   1         
1344   1            
1345   1         while(1)
1346   1         {
1347   2            
1348   2            //static UINT32 imaincount =0;
1349   2            
1350   2            //Switch_Delay1ms(100);  
1351   2            
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 23  

1352   2            
1353   2      //      if(flg_newnoise==1)
1354   2      //      {
1355   2      //         
1356   2      //         if(inoisevolume>0) 
1357   2      //         {
1358   2      //            inoisevolume--;
1359   2      //            set_realvolume(inoisevolume);
1360   2      //         }
1361   2      //         else
1362   2      //         {
1363   2      //            whitenoise_switch();
1364   2      //            flg_newnoise =2 ;
1365   2      //            
1366   2      //         }         
1367   2      //         
1368   2      //      }
1369   2      //      
1370   2      //      if(flg_newnoise==2)
1371   2      //      {
1372   2      //         if(inoisevolume<inoisevolume_top) 
1373   2      //         {
1374   2      //            inoisevolume++;
1375   2      //            set_realvolume(inoisevolume);
1376   2      //         }
1377   2      //         else
1378   2      //            flg_newnoise=0;            
1379   2      //      }
1380   2            
1381   2            
1382   2            //power key scan
1383   2            powerkey_scan();      
1384   2      
1385   2            
1386   2            //dowith power key  
1387   2            powerkey_process();     
1388   2      
1389   2       
1390   2            //get adc
1391   2            getadcvalue();   
1392   2            
1393   2      
1394   2            //adc key scan
1395   2            adckey_scan();   
1396   2            
1397   2            
1398   2            //P02=~P02;    //--timer line
1399   2            
1400   2            //adc key check         
1401   2            adckey_check();     
1402   2      
1403   2            //adc key process
1404   2            adckey_process( );           
1405   2            
1406   2      
1407   2            
1408   2         }
1409   1            
1410   1      
1411   1      }
1412          
1413          
C51 COMPILER V9.56.0.0   SNOOZ                                                             06/13/2019 11:49:35 PAGE 24  

1414          
1415          
1416          
1417          
1418          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4057    ----
   CONSTANT SIZE    =    144    ----
   XDATA SIZE       =    176     137
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
