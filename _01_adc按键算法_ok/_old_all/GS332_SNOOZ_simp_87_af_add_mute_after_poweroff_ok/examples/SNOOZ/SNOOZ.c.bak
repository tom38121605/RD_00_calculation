/*---------------------------------------------------------------------------------------------------------*/
/*                                                                                                         */
/* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                         */
/*                                                                                                         */
/*---------------------------------------------------------------------------------------------------------*/

//***********************************************************************************************************
//  Nuvoton Technoledge Corp. 
//  Website: http://www.nuvoton.com
//  E-Mail : MicroC-8bit@nuvoton.com
//  Date   : Apr/21/2017
//***********************************************************************************************************

//***********************************************************************************************************
//  File Function: N76E003 Timer2 Capture Mode demo code
//***********************************************************************************************************
#include "N76E003.h"
#include "Common.h"
#include "Delay.h"
#include "SFR_Macro.h"
#include "Function_Define.h"

#define TIMER1_RELOAD_VALUE     84
#define PWM_PERIOD 	0x1ff

/*
#define LPF_K 6
#define HARM_K 0
#define NOISE_K 0
#define K_OUT 0
#define INCR 4
*/

static S16 Harm_Val = 0x00;		// State for harmonic generator
static UINT16 LFSR = 0xff;			// Any non-zero value will work as the seed
static S16 LPF, L_OUT, S_OUT, LSB = 0x100;
static U8	CTR_DIR = 0; 
static U8	FN_MODE = 1;
static U8	WN_MODE = 1;


static U8 LPF_K = 5;
static U8 HARM_K = 7;
static U8 NOISE_K = 7;
static U8 INCR = 16;



/************************************************************************************************************
*   PWM interrupt subroutine
*		All signal processing happens here.
*		Runs at a fixed sample rate of 15.625 KHz
************************************************************************************************************/
void PWM_ISR (void) interrupt 13
{
	clr_PWMF;											// clear the interrupt flag
	P13 = 1;										// just an I/O marker to show activity
	
// Harmonics generator	
		if(CTR_DIR)
		{
			Harm_Val = (Harm_Val + INCR);
			if (Harm_Val >= 0x1FE)			// ramped to max?
			{	
				Harm_Val = 0x1FE;
				CTR_DIR = 0;
			}
		}
		else
		{
			Harm_Val = (Harm_Val - INCR);
			if (Harm_Val <= 0x0)			// ramped to zero?
			{
				Harm_Val = 1;
				CTR_DIR = 1;	
			}
		}

// White noise generator (Galois LFSR)
   LSB = LFSR & 0x01u;  					// Get LSB (i.e., the output bit)
   LFSR = (UINT16)LFSR >> 1; 			// Shift register 
   if (LSB)                   		// If the output bit is 1, 
			LFSR ^= 0xB400u;       			// Apply polynomial feedback. 
				
// Sum the noise and harmonics and apply the gain
		L_OUT = (S16)(((LFSR >> (NOISE_K + 7u))));		//kN . N
	  S_OUT = (S16)((Harm_Val >> HARM_K));					//kH . H
		L_OUT = (S16)(L_OUT + S_OUT);									//kH.H + kN.N

// Low Pass Filter (1st order IIR) 
		L_OUT = (S16)(L_OUT - LPF); 							// x[n] - y[n-1]
	  L_OUT = (S16)(L_OUT >> LPF_K);						// k(x[n] - y[n-1])
		L_OUT = (S16)(L_OUT + LPF);		// 					// k(x[n] - y[n-1]) + y[n-1]
		LPF = L_OUT;															// y[n] => y[n-1]
			
// set size and range of output data	
		L_OUT = (UINT16)(L_OUT & 0x1ff);
		if(L_OUT == 0)
			L_OUT = 0x0001;
		if(L_OUT == 0x01ff)
			L_OUT = 0x01fe;		
				
// DAC output				
		PWM2H = (UINT16)(L_OUT >> 8) & 0x01;						
		PWM2L = L_OUT & 0xff;	
		set_LOAD;										// latch the updated PWM value to the PWM engine
		P13 = 0;										// just an I/O marker to show activity
}


/************************************************************************************************************
*    Main function 
************************************************************************************************************/
void main (void)
{   
		Timer0_Delay1ms(500);
    Set_All_GPIO_Quasi_Mode;	
		InitialUART0_Timer3(115200);
		P04_Input_Mode;
		P03_Input_Mode;
		P01_Input_Mode;
		set_HIRCST;
		Enable_ADC_AIN5;
		clr_ADCF;
		set_ADCS;									// ADC start trig signal

// set up IO
		P05_PushPull_Mode;
//set up PWM2, this will be the noise source DAC
		PWM2_P05_OUTPUT_ENABLE;
		PWM_INT_PWM2;	
		PWM_FALLING_INT;					//Setting Interrupt happen when PWM0 falling signal
	
		PWM_CLOCK_DIV_2;
		PWMPH = 0x01;							//Setting PWM period
		PWMPL = 0xFF;
		PWM2H = 0x00;							//PWM0 high duty = 1/2 PWM period
		PWM2L = 0x01;	

		set_EPWM;									//Enable PWM interrupt
		set_EA;									
    set_LOAD;
    set_PWMRUN;
		printf("\n Code Start\n");
    while(1)
		{
				// white noise switch
				if (P01)
				{
					WN_MODE++;
					if(WN_MODE == 4)
						WN_MODE = 1;
					printf("White Noise %c, counter = %d\n",WN_MODE,Harm_Val);
					P01 = 0;
					Timer0_Delay1ms(300);
					switch(WN_MODE)
					{
						case 1:
						{
							LPF_K = 5;
							HARM_K = 7;
							NOISE_K = 1;
							INCR = 0;		
							break;							
						}
						case 2:
						{
							LPF_K = 3;
							HARM_K = 7;
							NOISE_K = 2;
							INCR = 0;		
							break;							
						}
						case 3:
						{
							LPF_K = 1;
							HARM_K = 7;
							NOISE_K = 3;
							INCR = 0;		
							break;							
						}	
					}						
				}
				
				// fan noise switch
				if (P03)
				{
					FN_MODE++;
					if(FN_MODE == 4)
						FN_MODE = 1;					
					printf("Fan Noise %c, counter = %d\n",FN_MODE,S_OUT);
					P03 = 0;
					Timer0_Delay1ms(300);
					switch(FN_MODE)
					{
						case 1:
						{
							LPF_K = 6;
							HARM_K = 1;
							NOISE_K = 1;
							INCR = 5;		
							break;							
						}
						case 2:
						{
							LPF_K = 4;
							HARM_K = 3;
							NOISE_K = 2;
							INCR = 6;		
							break;							
						}
						case 3:
						{
							LPF_K = 2;
							HARM_K = 4;
							NOISE_K = 3;
							INCR = 7;		
							break;							
						}	
					}						
				}
				if (P04)
				{
					printf("\n Button #3");
					P04 = 0;
					Timer0_Delay1ms(300);
				}		
		}
}
