C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_c51\C51\BIN\C51.EXE Code\main.c LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\..\Include) DEFINE
                    -(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\main.lst) TABS(3) OBJECT(.\Output\main.obj)

line level    source

   1          #include "N76E003.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "Common.h"
   5          #include "Delay.h"
   6          #include <string.h>
   7          
   8          
   9          #include "i2c_VCNL3020.h"
  10          
  11          
  12          unsigned char temp _at_ 0x08;
  13          unsigned char idata itemp _at_ 0x80;
  14          unsigned char xdata xtemp _at_ 0x80;
  15          
  16          
  17          
  18          //i2c
  19          
  20          #define I2C_CLOCK_50KHz     79 
  21          #define I2C_CLOCK_100KHz    39 
  22          #define I2C_CLOCK_200KHz    19 
  23          #define I2C_CLOCK_400KHz    9 
  24          
  25          //#define SLAVEADDR_SLA       0x26  
  26          #define SLAVEADDR_SLA       (0x44 << 1 )  
  27          
  28          #define SLAVEADDR_WR               0
  29          #define SLAVEADDR_RD               1
  30          
  31          bit I2C_Reset_Flag;
  32           
  33          //result value
  34          
  35          UINT8 flg_sensor_init =0;
  36          
  37          UINT16 RESULT1_COMEOUT =0;
  38          UINT16 RESULT1_COMEIN =0;
  39          UINT16 RESULT2_COMEOUT =0;
  40          UINT16 RESULT2_COMEIN =0;
  41          
  42          #define RESULT_LOWEST  80
  43          
  44          
  45          //#define CENTER_RANGE  40
  46          //#define PROX_GAP  15
  47          
  48          //#define CENTER_RANGE  30
  49          //#define PROX_GAP  15
  50          #define PROX_IN_GAP   45
  51          #define PROX_OUT_GAP  15
  52          
  53          
  54          #define SENSOR_R_PIN   P04
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 2   

  55          #define SENSOR_R_PUSHPULL_MODE        P04_PushPull_Mode
  56          
  57          #define SENSOR_L_PIN   P30
  58          #define SENSOR_L_PUSHPULL_MODE        P30_PushPull_Mode
  59          
  60          UINT16 iLTA_value1=0; 
  61          UINT16 iresultvalue1=0; 
  62          UINT16 iresultvalue1_out=0;
  63          UINT16 iresultvalue1_avr=0;
  64          UINT16 iresultvalue1_delay=0;
  65          UINT32 iresultcount1=0;
  66          //UINT32 iresultvalue1_sum = 0;
  67          
  68          UINT16 iLTA_value2=0; 
  69          UINT16 iresultvalue2=0; 
  70          UINT16 iresultvalue2_out=0;
  71          UINT16 iresultvalue2_avr=0;
  72          UINT16 iresultvalue2_delay=0;
  73          UINT32 iresultcount2=0;
  74          //UINT32 iresultvalue2_sum = 0;
  75          
  76          
  77          #define AVRBITCOUNT    4
  78          #define AVRREADYCOUNT  200
  79          
  80          UINT8 stemp11[20]={0};
  81          UINT8 stemp12[20]={0};
  82          UINT8 stemp13[20]={0};
  83          UINT8 stemp15[20]={0};
  84          
  85          UINT8 stemp21[20]={0};
  86          UINT8 stemp22[20]={0};
  87          UINT8 stemp23[20]={0};
  88          UINT8 stemp25[20]={0};
  89          
  90          
  91          //sensor pin
  92          #define SENSOR_L_PIN                  P30   
  93          #define SENSOR_L_PUSHPULL_MODE        P30_PushPull_Mode
  94          
  95          #define SENSOR_R_PIN                  P04   
  96          #define SENSOR_R_PUSHPULL_MODE        P04_PushPull_Mode
  97          
  98            
  99          //adc
 100          UINT16 BAND_value=0;
 101          
 102          #define BAND_3300 1448
 103          
 104          #define RESISTOR_UP_K     10
 105          #define RESISTOR_DOWN_K   15
 106           
 107          UINT16 iadcvalue=0;
 108            
 109          UINT16 iadcvalue_out=0;
 110           
 111          UINT16 iadcvalue_avr=0;
 112           
 113          UINT16 iadcvalue_delay=0;
 114           
 115          UINT8 iadccount=0;
 116          
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 3   

 117          UINT8 flg_channel =0;
 118          
 119          UINT8 sadctemp1[20];
 120          UINT8 sadctemp2[20];
 121          
 122          UINT8 sadcstate[20];
 123          
 124          //double fadc_key=0;
 125          UINT16 iadc_key=0;
 126          
 127          
 128          //key 
 129          //#define KEY0_NC_PIN                  P17   //--test
 130          //#define KEY0_NC_PUSHPULL_MODE        P17_PushPull_Mode
 131          UINT8   KEY0_NC_PIN  =0; 
 132          
 133          #define KEY1_L_PIN                   P11
 134          #define KEY1_L_PUSHPULL_MODE         P11_PushPull_Mode
 135          
 136          #define KEY2_CENTER_PIN              P00
 137          #define KEY2_CENTER_PUSHPULL_MODE    P00_PushPull_Mode
 138          
 139          #define KEY3_DOWN_PIN                P10
 140          #define KEY3_DOWN_PUSHPULL_MODE      P10_PushPull_Mode
 141          
 142          #define KEY4_R_PIN                   P12
 143          #define KEY4_R_PUSHPULL_MODE         P12_PushPull_Mode
 144          
 145          #define KEY5_UP_PIN                  P15
 146          #define KEY5_UP_PUSHPULL_MODE        P15_PushPull_Mode
 147          
 148          
 149          #define ADC_VOL_GAP                 200   
 150          
 151          //#define ADC_VOL_L                   (800  - ADC_VOL_GAP)     
 152          //#define ADC_VOL_CENTER              (1300 - ADC_VOL_GAP)
 153          //#define ADC_VOL_DOWN                (1900 - ADC_VOL_GAP)   
 154          //#define ADC_VOL_R                   (2300 - ADC_VOL_GAP)
 155          //#define ADC_VOL_UP                  (2700 - ADC_VOL_GAP)
 156          
 157          #define ADC_VOL_UP                  (800  - ADC_VOL_GAP)     
 158          #define ADC_VOL_CENTER              (1300 - ADC_VOL_GAP)
 159          #define ADC_VOL_L                   (1900 - ADC_VOL_GAP)   
 160          #define ADC_VOL_DOWN                (2300 - ADC_VOL_GAP)
 161          #define ADC_VOL_R                   (2700 - ADC_VOL_GAP)
 162          
 163          
 164          #define ADC_VOL_NC                  300   //(ADC_VOL_L  - ADC_VOL_GAP)    
 165          #define ADC_VOL_NC2                 3000  //(ADC_VOL_UP + ADC_VOL_GAP)    
 166          
 167          
 168          //led current
 169          #define IRLED_CURRENT   1    //1 = 10 mA, бн., 20 = 200 mA (2 = 20 mA = DEFAULT)
 170          #define IRLED_CURRENT2  1    
 171          UINT8 icur =0; 
 172          
 173           
 174          
 175          //timer1
 176          UINT32 itimer1_count=0;
 177          UINT32 itimer1_count2=0;
 178          //UINT32 itimer1_count3=0;
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 4   

 179          
 180          UINT32 iltascan=0;
 181          
 182             
 183          void iputs0(UINT8 *msg)
 184          {
 185   1         while(*msg)
 186   1             Send_Data_To_UART0(*msg++);
 187   1      }
 188          
 189          
 190          //void Init_I2C(void)
 191          //{
 192          //   P13_OpenDrain_Mode;             
 193          //   P14_OpenDrain_Mode;             
 194          
 195          //   // Set I2C clock rate  
 196          //   //I2CLK =  I2C_CLOCK_400KHz; 
 197          //   I2CLK =  I2C_CLOCK_100KHz; 
 198          //   //I2CLK =  I2C_CLOCK_50KHz; 
 199          
 200          //   // Enable I2C  
 201          //   set_I2CEN;                                   
 202          //}
 203          
 204          void Init_I2C_P13_P14(void)
 205          {
 206   1         P13_OpenDrain_Mode;            
 207   1         P14_OpenDrain_Mode;  
 208   1         
 209   1         clr_I2CEN; 
 210   1      
 211   1         clr_I2CPX;   
 212   1      
 213   1         // Set I2C clock rate  
 214   1         I2CLK =  I2C_CLOCK_400KHz;    
 215   1      
 216   1         // Enable I2C  
 217   1         set_I2CEN;   
 218   1         
 219   1      }
 220          
 221          void Init_I2C_P02_P16(void)
 222          {
 223   1         P02_OpenDrain_Mode;            
 224   1         P16_OpenDrain_Mode;  
 225   1         
 226   1         clr_I2CEN; 
 227   1         
 228   1         set_I2CPX;   
 229   1      
 230   1         // Set I2C clock rate  
 231   1         I2CLK =  I2C_CLOCK_400KHz; 
 232   1      
 233   1      
 234   1         // Enable I2C  
 235   1         set_I2CEN;                                   
 236   1      }
 237          
 238          
 239          void I2C_SI_Check(void)
 240          {
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 5   

 241   1         if (I2STAT == 0x00)
 242   1         {
 243   2            I2C_Reset_Flag = 1;
 244   2            set_STO;
 245   2            SI = 0;
 246   2            if(SI)
 247   2            {
 248   3               clr_I2CEN;
 249   3               set_I2CEN;
 250   3               clr_SI;
 251   3               clr_I2CEN;     
 252   3            }  
 253   2         }  
 254   1         
 255   1      }
 256          
 257          
 258          void i2c_write( UINT8 iaddr, UINT8 *sbuf, UINT8 ilen )
 259          {
 260   1         
 261   1          UINT8  u8Count;
 262   1      
 263   1          /* Step1 */
 264   1          set_STA;                                /* Send Start bit to I2C EEPROM */         
 265   1          clr_SI;
 266   1          while (!SI);
 267   1         
 268   1          if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
 269   1          {
 270   2              I2C_Reset_Flag = 1;
 271   2              iputs0("WR Send STAw' error\r\n");
 272   2              goto Write_Error_Stop;
 273   2          }
 274   1          
 275   1          clr_STA; 
 276   1          
 277   1      
 278   1          /* Step2 */
 279   1          //--clr_STA;                                /* Clear STA and Keep SI value in I2CON */
 280   1          I2DAT = SLAVEADDR_SLA | SLAVEADDR_WR;         /* Send (SLA+W) to EEPROM */
 281   1          clr_SI;
 282   1          while (!SI);
 283   1          if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -            
 284   1          {
 285   2              I2C_Reset_Flag = 1;       
 286   2              //iputs0("I2C 'Send SLA+W' error\r\n");
 287   2             
 288   2              goto Write_Error_Stop;
 289   2          }
 290   1      
 291   1          /* Step3 */
 292   1          I2DAT = iaddr;             /* Send EEPROM's  Address */
 293   1          clr_SI;
 294   1          while (!SI);
 295   1          if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */
 296   1          {
 297   2              I2C_Reset_Flag = 1;
 298   2              //iputs0("I2C 'Send sub address' error\r\n");
 299   2              goto Write_Error_Stop;
 300   2          }
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 6   

 301   1       
 302   1      
 303   1          /* Step5 */
 304   1          /* Write data to I2C EEPROM */ 
 305   1      
 306   1          for (u8Count = 0; u8Count < ilen; u8Count++)
 307   1          {
 308   2          
 309   2            I2DAT = sbuf[u8Count];                    /* Send data to EEPROM */
 310   2            clr_SI;
 311   2            while (!SI);
 312   2            if (I2STAT != 0x28)                 /* 0x28:  Data byte in S1DAT has been transmitted; ACK has been 
             -received */
 313   2            {
 314   3               I2C_Reset_Flag = 1;
 315   3               //iputs0("I2C 'Write Data' error\r\n");
 316   3               goto Write_Error_Stop;
 317   3            }   
 318   2         }
 319   1       
 320   1         
 321   1         /* Step6 */
 322   1      
 323   1         set_STO;                           
 324   1         clr_SI;
 325   1         while (STO);
 326   1         
 327   1      
 328   1      //iputs0("I2C write ok\r\n");   //--test
 329   1         
 330   1       
 331   1      Write_Error_Stop: 
 332   1      
 333   1         
 334   1         if (I2C_Reset_Flag)
 335   1         {
 336   2            
 337   2            set_STO;                           
 338   2            clr_SI;
 339   2            while (STO);
 340   2      
 341   2            I2C_SI_Check();
 342   2            I2C_Reset_Flag = 0;
 343   2            //iputs0("I2C Write error, test stop\r\n");
 344   2            
 345   2            //test
 346   2            I2CEN=0;
 347   2            I2CEN=1;       
 348   2         }  
 349   1      
 350   1            
 351   1      }
 352          
 353          
 354          void i2c_read( UINT8 iaddr, UINT8 *sbuf, UINT8 ilen )
 355          {
 356   1          UINT8  u8Count; 
 357   1         
 358   1      
 359   1          /* Step1 */
 360   1          set_STA;                                /* Send Start bit to I2C EEPROM */
 361   1          clr_SI;
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 7   

 362   1          while (!SI);
 363   1          if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
 364   1          {
 365   2            I2C_Reset_Flag = 1;
 366   2            iputs0("RD Send STAR' error\r\n");
 367   2            goto Read_Error_Stop;
 368   2          }
 369   1      
 370   1          /* Step2 */
 371   1          I2DAT = (SLAVEADDR_SLA | SLAVEADDR_WR);       /* Send (SLA+W) to EEPROM */
 372   1          clr_STA;                                /* Clear STA and Keep SI value in I2CON */    
 373   1          clr_SI;
 374   1          while (!SI);
 375   1          if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -             
 376   1          {
 377   2            I2C_Reset_Flag = 1;
 378   2            //iputs0("I2C 'Send SLA+W' error\r\n");
 379   2            goto Read_Error_Stop;
 380   2          }
 381   1      
 382   1          /* Step3 */
 383   1          I2DAT = iaddr;             /* Send I2C EEPROM's Address */
 384   1          clr_SI;
 385   1          while (!SI);
 386   1          if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */              
 387   1          {
 388   2            I2C_Reset_Flag = 1;
 389   2            //iputs0("I2C 'Send I2C High Byte Address' error\r\n");
 390   2            goto Read_Error_Stop;
 391   2          }
 392   1       
 393   1          /* Step5 */
 394   1          set_STA;                                /* Repeated START */
 395   1          clr_SI; 
 396   1          while (!SI);
 397   1          if (I2STAT != 0x10)                     /* 0x10: A repeated START condition has been transmitted */
 398   1          {
 399   2            I2C_Reset_Flag = 1;
 400   2            //iputs0("I2C 'Send STA' error\r\n");
 401   2            goto Read_Error_Stop;
 402   2          }
 403   1      
 404   1          /* Step6 */
 405   1          clr_STA;                                /* Clear STA and Keep SI value in I2CON */
 406   1          I2DAT = (SLAVEADDR_SLA | SLAVEADDR_RD);       /* Send (SLA+R) to EEPROM */
 407   1          clr_SI;
 408   1          while (!SI);
 409   1          if (I2STAT != 0x40)                     /* 0x40:  SLA+R has been transmitted; ACK has been received */
             -              
 410   1          {
 411   2            I2C_Reset_Flag = 1;
 412   2            //iputs0("I2C 'Send SLA+R' error\r\n");
 413   2            goto Read_Error_Stop;
 414   2          }
 415   1      
 416   1          /* Step7 */                             /* Verify I2C EEPROM data */
 417   1          for (u8Count = 0; u8Count <ilen; u8Count++)
 418   1          {
 419   2              set_AA;                             /* Set Assert Acknowledge Control Bit */
 420   2              clr_SI;
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 8   

 421   2              while (!SI);
 422   2              if (I2STAT != 0x50)                 /* 0x50:Data byte has been received; NOT ACK has been returned
             - */              
 423   2              {
 424   3                  I2C_Reset_Flag = 1;
 425   3                  //iputs0("I2C 'No Ack' error\r\n");
 426   3                  goto Read_Error_Stop;
 427   3              }
 428   2             
 429   2              sbuf[u8Count] = I2DAT;
 430   2          }
 431   1      
 432   1          /* Step8 */
 433   1          clr_AA;                                 /* Send a NACK to disconnect 24xx64 */
 434   1          clr_SI;
 435   1          while (!SI);
 436   1          if (I2STAT != 0x58)                     /* 0x58:Data byte has been received; ACK has been returned */
 437   1          {
 438   2              I2C_Reset_Flag = 1;
 439   2              //iputs0("I2C 'Ack' error\r\n");
 440   2              goto Read_Error_Stop;
 441   2          }
 442   1          
 443   1         /* Step9 */    
 444   1          clr_SI;
 445   1          set_STO;
 446   1          
 447   1          while (STO);
 448   1          
 449   1          
 450   1      //iputs0("I2C Read ok\r\n");   //--test
 451   1              
 452   1       
 453   1      Read_Error_Stop: 
 454   1         if (I2C_Reset_Flag)
 455   1         {
 456   2            I2C_SI_Check();
 457   2            //--iputs0("I2C Read error, test stop\r\n");
 458   2            I2C_Reset_Flag = 0;
 459   2            
 460   2            //test
 461   2            I2CEN=0;
 462   2            I2CEN=1; 
 463   2         }
 464   1         
 465   1         
 466   1         
 467   1      }
 468          
 469           
 470          
 471          //void set_current(UINT8 icur)
 472          //{
 473          
 474          //   UINT8 sbuf1[10]={0};
 475          //   UINT8 sbuf2[10]={0};
 476          //   //UINT8 stemp[20]={0};   
 477          //   
 478          //   //set the IR LED current
 479          //   sbuf2[0]=0; 
 480          //   i2c_read(REG03, sbuf2, 1);    
 481          //   
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 9   

 482          //   sbuf2[0] &= 0xc0;  
 483          //   sbuf2[0]|= icur;  
 484          //   i2c_write(REG03, sbuf2, 1);
 485          //   Timer0_Delay1ms(10);  
 486          //   
 487          //}
 488          
 489          //void set_current2(UINT8 icur)
 490          //{
 491          
 492          //   UINT8 sbuf1[10]={0};
 493          //   UINT8 sbuf2[10]={0};
 494          //   //UINT8 stemp[20]={0};   
 495          //   
 496          //   //set the IR LED current
 497          //   //sbuf2[0]=0; 
 498          //   
 499          //   //i2c_read(REG03, sbuf2, 1);
 500          //   sbuf2[0]=VCNL3020_ReadOneByte(REG03);
 501          //  
 502          //   sbuf2[0] &= 0xc0;  
 503          //   sbuf2[0]|= icur; 
 504          //   
 505          //   //i2c_write(REG03, sbuf2, 1);
 506          //   VCNL3020_WriteOneByte(REG03, sbuf2[0]);
 507          //   Timer0_Delay1ms(10);  
 508          //   
 509          //}
 510          
 511          double  Bandgap_Voltage;
 512          void READ_BANDGAP(void)
 513          {
 514   1            UINT8 BandgapHigh,BandgapLow,BandgapMark;
 515   1            double Bandgap_Value,Bandgap_Voltage_Temp;
 516   1      
 517   1            set_IAPEN;
 518   1            IAPCN = READ_UID;
 519   1            IAPAL = 0x0d;
 520   1            IAPAH = 0x00;
 521   1            set_IAPGO;
 522   1            BandgapLow = IAPFD;
 523   1            BandgapMark = BandgapLow&0xF0;
 524   1               
 525   1            if (BandgapMark==0x80)
 526   1            {
 527   2                  BandgapLow = BandgapLow&0x0F;
 528   2                  IAPAL = 0x0C;
 529   2                  IAPAH = 0x00;
 530   2                  set_IAPGO;
 531   2                  BandgapHigh = IAPFD;
 532   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 533   2                  Bandgap_Voltage_Temp = Bandgap_Value*3/4;
 534   2                  Bandgap_Voltage = Bandgap_Voltage_Temp - 33;       //the actually banggap voltage value is similar this va
             -lue.
 535   2            }
 536   1            if (BandgapMark==0x00)
 537   1            {
 538   2                  BandgapLow = BandgapLow&0x0F;
 539   2                  IAPAL = 0x0C;
 540   2                  IAPAH = 0x00;
 541   2                  set_IAPGO;
 542   2                  BandgapHigh = IAPFD;
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 10  

 543   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 544   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 545   2            }
 546   1            if (BandgapMark==0x90)
 547   1            {
 548   2                  IAPAL = 0x0E;
 549   2                  IAPAH = 0x00;
 550   2                  set_IAPGO;
 551   2                  BandgapHigh = IAPFD;
 552   2                  IAPAL = 0x0F;
 553   2                  IAPAH = 0x00;
 554   2                  set_IAPGO;
 555   2                  BandgapLow = IAPFD;
 556   2                  BandgapLow = BandgapLow&0x0F;
 557   2                  Bandgap_Value = (BandgapHigh<<4)+BandgapLow;
 558   2                  Bandgap_Voltage= Bandgap_Value*3/4;
 559   2            }
 560   1            clr_IAPEN;
 561   1            
 562   1      //       printf ("\n BG High = %bX",BandgapHigh); 
 563   1      //       printf ("\n BG Low = %bX",BandgapLow); 
 564   1      //       printf ("\n BG ROMMAP = %e",Bandgap_Voltage); 
 565   1            
 566   1      }
 567          
 568          
 569          
 570          void adcscan (UINT8 icomindex) 
 571          {  
 572   1         UINT8 stemp2[20]={0}; 
 573   1         UINT16 AIN_value=0;
 574   1         double iadc =0;
 575   1         
 576   1         
 577   1         //-------------BAND-----------------
 578   1         
 579   1         Enable_ADC_BandGap;    
 580   1         CKDIV = 0x02;  
 581   1      
 582   1         
 583   1         clr_ADCF;
 584   1         set_ADCS;                               
 585   1         while(ADCF == 0);  
 586   1      
 587   1         BAND_value =  ADCRH ;
 588   1         BAND_value <<=  4 ;
 589   1         BAND_value |=  ADCRL & 0x0f ;      
 590   1      
 591   1         CKDIV = 0;  
 592   1         Disable_ADC;      
 593   1            
 594   1         switch (icomindex)
 595   1         {  
 596   2           
 597   2            case 0:      
 598   2               
 599   2               //-------------AIN4-----------------
 600   2               
 601   2               Enable_ADC_AIN4;      
 602   2               
 603   2               clr_ADCF;
 604   2               set_ADCS;                      
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 11  

 605   2      
 606   2               while(ADCF == 0);
 607   2               
 608   2               AIN_value =  ADCRH ;
 609   2               AIN_value <<=  4 ;
 610   2               AIN_value |=  ADCRL & 0x0f ;      
 611   2               
 612   2               iadc =   Bandgap_Voltage * AIN_value  / BAND_value ;  //mv        
 613   2               iadcvalue = (UINT16)iadc;
 614   2            
 615   2            
 616   2               iadcvalue_out = ( (INT16) (iadcvalue -  iadcvalue_delay) >>AVRBITCOUNT ) + iadcvalue_delay;
 617   2               iadcvalue_delay = iadcvalue_out; 
 618   2      
 619   2      
 620   2               flg_channel=1;
 621   2             
 622   2               Disable_ADC;
 623   2               
 624   2               break;
 625   2            
 626   2               
 627   2            default:
 628   2      
 629   2               break;
 630   2            
 631   2        }   
 632   1         
 633   1      }
 634          
 635          
 636          #define TIMER_DIV12_COUNT_10ms         65536-13334 
 637          #define TIMER_DIV12_COUNT_3ms          65536-4000
 638          #define TIMER_DIV12_COUNT_2ms          65536-2667
 639          #define TIMER_DIV12_COUNT_1ms          65536-1334
 640          #define TIMER_DIV12_COUNT_500us        65536-667
 641          #define TIMER_DIV12_COUNT_100us        65536-133
 642          #define TIMER_DIV12_COUNT_50us         65536-67
 643          
 644          
 645          #define TIMER_DIV12_COUNT  TIMER_DIV12_COUNT_1ms   
 646          
 647          void Timer1_ISR (void) interrupt 3 
 648          {   
 649   1         static UINT8 iscanindex =0;  
 650   1      
 651   1         itimer1_count++;     
 652   1         itimer1_count2++;     
 653   1         //itimer1_count3++;     
 654   1         
 655   1      
 656   1         TL1 = TIMER_DIV12_COUNT & 0xFF;      
 657   1         TH1 = TIMER_DIV12_COUNT >> 8 ;      
 658   1      
 659   1         
 660   1         adcscan(iscanindex);   
 661   1         
 662   1         
 663   1         iscanindex=0;
 664   1         //if(iscanindex<4)
 665   1         //   iscanindex++;
 666   1         //else
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 12  

 667   1         //   iscanindex=0;   
 668   1         
 669   1      }
 670          
 671          void timer1_init (void)
 672          {
 673   1         
 674   1         TIMER1_MODE1_ENABLE;
 675   1      
 676   1         clr_T1M;      //  sysclk/12   
 677   1         //set_T1M;      //  sysclk
 678   1      
 679   1         TL1 = TIMER_DIV12_COUNT & 0xff;      
 680   1         TH1 = TIMER_DIV12_COUNT >> 8 ;   
 681   1         
 682   1      
 683   1         set_ET1;                                    
 684   1         set_EA;                                     
 685   1      
 686   1         set_TR1;     //Timer1 run
 687   1         
 688   1      }
 689          
 690          
 691          //void set_config(void)
 692          //{
 693          //   UINT8 sbuf2[10]={0};
 694          //   //UINT8 stemp[20]={0}; 
 695          //   
 696          //   //set period measurement
 697          //   sbuf2[0]=0; 
 698          //   i2c_read(REG00, sbuf2, 1);    
 699          
 700          //   sbuf2[0] |= (1<<0 )| (1<<1); 
 701          //   
 702          //   i2c_write(REG00, sbuf2, 1);
 703          //   Timer0_Delay1ms(10); 
 704          //   
 705          //   //sbuf2[0]=0; 
 706          //   //i2c_read(REG00, sbuf2, 1);    
 707          //   //sprintf (stemp,"reg00 = %bu\r\n",sbuf2[0]); 
 708          //   //iputs0(stemp);
 709          //   //Timer0_Delay1ms(10);    
 710          //   
 711          //}
 712          
 713          //void set_config2(void)
 714          //{
 715          //   UINT8 sbuf2[10]={0};
 716          //   //UINT8 stemp[20]={0};
 717          //    
 718          //   //set period measurement
 719          //   sbuf2[0] = VCNL3020_ReadOneByte(REG00);
 720          //   sbuf2[0] |= (1<<0 )| (1<<1); 
 721          
 722          //   VCNL3020_WriteOneByte(REG00, sbuf2[0]); 
 723          //   Timer0_Delay1ms(10); 
 724          //   
 725          //   //sbuf2[0] = VCNL3020_ReadOneByte(REG00);   
 726          //   //sprintf (stemp,"reg00 = %bu\r\n",sbuf2[0]); 
 727          //   //iputs0(stemp);
 728          //   //Timer0_Delay1ms(10);    
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 13  

 729          //       
 730          //}
 731          
 732          
 733          //void get_resultvalue1(void)
 734          //{  
 735          //   UINT8 sbuf1[10]={0};
 736          //   UINT8 sbuf2[10]={0};   
 737          //            
 738          //   sbuf2[0]=0; sbuf2[1]=0; 
 739          //   i2c_read(REG07, sbuf2, 1);   
 740          //   i2c_read(REG08, sbuf2+1, 1);         
 741          //   
 742          //   iresultvalue1 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 743          //   sprintf (stemp12,"new1 = %u\r\n", iresultvalue1 );       
 744          
 745          //   iresultvalue1_out = ( (INT16) (iresultvalue1 -  iresultvalue1_delay) >>AVRBITCOUNT ) + iresultvalue1_
             -delay;
 746          //   iresultvalue1_delay = iresultvalue1_out; 
 747          
 748          
 749          //   //if(iresultcount1++>AVRREADYCOUNT)
 750          //   //{
 751          //   //   iresultcount1 =AVRREADYCOUNT+10;
 752          //   //   iresultvalue1_avr = iresultvalue1_out;
 753          //   //}
 754          //   //else
 755          //   //   iresultvalue1_avr = iresultvalue1;  
 756          //   iresultvalue1_avr = iresultvalue1;
 757          
 758          //   sprintf (stemp13,"avr1-R = %u\r\n", iresultvalue1_avr );     
 759          //}      
 760          
 761          
 762          //void get_resultvalue2(void)
 763          //{  
 764          //   UINT8 sbuf1[10]={0};
 765          //   UINT8 sbuf2[10]={0};   
 766          //            
 767          //   sbuf2[0]=0; sbuf2[1]=0; 
 768          //   
 769          //   //i2c_read(REG07, sbuf2, 1);   
 770          //   //i2c_read(REG08, sbuf2+1, 1);  
 771          //   sbuf2[0]=VCNL3020_ReadOneByte(REG07);   
 772          //   sbuf2[1]=VCNL3020_ReadOneByte(REG08);  
 773          //   
 774          //   
 775          //   iresultvalue2 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 776          //   sprintf (stemp22,"new2 = %u\r\n", iresultvalue2 );       
 777          
 778          //   iresultvalue2_out = ( (INT16) (iresultvalue2 -  iresultvalue2_delay) >>AVRBITCOUNT ) + iresultvalue2_
             -delay;
 779          //   iresultvalue2_delay = iresultvalue2_out; 
 780          
 781          
 782          //   //if(iresultcount2++>AVRREADYCOUNT)
 783          //   //{
 784          //   //   iresultcount2 =AVRREADYCOUNT+10;
 785          //   //   iresultvalue2_avr = iresultvalue2_out;
 786          //   //}
 787          //   //else
 788          //   //   iresultvalue2_avr = iresultvalue2;      
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 14  

 789          //   iresultvalue2_avr = iresultvalue2;     
 790          
 791          //   sprintf (stemp23,"avr2-L = %u\r\n", iresultvalue2_avr );     
 792          //}      
 793          
 794          
 795          #define AVERAGENUM    8 
 796          #define BITMOVE16     3 
 797          UINT16 get16_avr( UINT16 inew)
 798          {
 799   1         static UINT8 icount =0;                      
 800   1         static UINT32 isum=0;      
 801   1         
 802   1         static UINT16 iavr=0;   
 803   1         static UINT16 iold[AVERAGENUM] ={0};   
 804   1      
 805   1         
 806   1         if (icount<=AVERAGENUM)
 807   1            icount++;
 808   1         else
 809   1            icount=AVERAGENUM+1;
 810   1      
 811   1      
 812   1         if (icount<=AVERAGENUM)
 813   1         {                       
 814   2            iavr=inew;
 815   2            isum = isum + inew;
 816   2            
 817   2            iold[icount-1] = inew;
 818   2         }
 819   1         else
 820   1         {                       
 821   2            isum = isum + inew - iold[0];
 822   2            
 823   2            //iavr=(UINT16)(isum/AVERAGENUM);     
 824   2            iavr=(isum>>BITMOVE16); 
 825   2      
 826   2            memcpy(&iold[0],&iold[1],(AVERAGENUM-1)*sizeof(UINT16));
 827   2      
 828   2            iold[(AVERAGENUM-1)] = inew;        
 829   2         }  
 830   1      
 831   1         return iavr;   
 832   1      }  
 833          
 834          UINT16 get16_avr2( UINT16 inew)
 835          {
 836   1         static UINT8 icount =0;                      
 837   1         static UINT32 isum=0;      
 838   1         
 839   1         static UINT16 iavr=0;   
 840   1         static UINT16 iold[AVERAGENUM] ={0};   
 841   1      
 842   1         
 843   1         if (icount<=AVERAGENUM)
 844   1            icount++;
 845   1         else
 846   1            icount=AVERAGENUM+1;
 847   1      
 848   1      
 849   1         if (icount<=AVERAGENUM)
 850   1         {                       
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 15  

 851   2            iavr=inew;
 852   2            isum = isum + inew;
 853   2            
 854   2            iold[icount-1] = inew;
 855   2         }
 856   1         else
 857   1         {                       
 858   2            isum = isum + inew - iold[0];
 859   2            
 860   2            //iavr=(UINT16)(isum/AVERAGENUM);     
 861   2            iavr=(isum>>BITMOVE16); 
 862   2      
 863   2            memcpy(&iold[0],&iold[1],(AVERAGENUM-1)*sizeof(UINT16));
 864   2      
 865   2            iold[(AVERAGENUM-1)] = inew;        
 866   2         }  
 867   1      
 868   1         return iavr;   
 869   1      }  
 870          
 871          //void get_resultvalue1(void)
 872          //{  
 873          //   UINT8 sbuf1[10]={0};
 874          //   UINT8 sbuf2[10]={0};  
 875          
 876          //   Init_I2C_P13_P14();      
 877          //            
 878          //   //get count0
 879          //   sbuf2[0]=0; sbuf2[1]=0; 
 880          //   i2c_read(0x21, sbuf2, 1);   
 881          //   i2c_read(0x20, sbuf2+1, 1);        
 882          //   
 883          //   //clr_I2CEN;
 884          //   
 885          //   iresultvalue1 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 886          //   sprintf (stemp12,"new1 = %u\r\n", iresultvalue1 );   
 887          // 
 888          ////iputs0(stemp12);   
 889          //   
 890          
 891          //   iresultvalue1_out = ( (INT16) (iresultvalue1 -  iresultvalue1_delay) >>AVRBITCOUNT ) + iresultvalue1_
             -delay;
 892          //   iresultvalue1_delay = iresultvalue1_out; 
 893          
 894          
 895          //   //if(iresultcount1++>AVRREADYCOUNT)
 896          //   //{
 897          //   //   iresultcount1 =AVRREADYCOUNT+10;
 898          //   //   iresultvalue1_avr = iresultvalue1_out;
 899          //   //}
 900          //   //else
 901          //   //   iresultvalue1_avr = iresultvalue1;
 902          //   
 903          //   //iresultvalue1_avr = iresultvalue1;  
 904          //   iresultvalue1_avr = get16_avr(iresultvalue1);     
 905          
 906          //   sprintf (stemp13,"a1=%u\r\n", iresultvalue1_avr );   
 907          //  
 908          //}      
 909          
 910          //void get_resultvalue2(void)
 911          //{  
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 16  

 912          //   UINT8 sbuf1[10]={0};
 913          //   UINT8 sbuf2[10]={0};  
 914          
 915          //   Init_I2C_P02_P16();      
 916          //            
 917          //   //get count0
 918          //   sbuf2[0]=0; sbuf2[1]=0; 
 919          //   i2c_read(0x21, sbuf2, 1);   
 920          //   i2c_read(0x20, sbuf2+1, 1);        
 921          //   
 922          //   //clr_I2CEN;
 923          //   
 924          //   iresultvalue2 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 925          //   sprintf (stemp22,"new2 = %u\r\n", iresultvalue2 );      
 926          //   
 927          ////iputs0(stemp22); 
 928          ////iputs0("\r\n");     
 929          
 930          //   iresultvalue2_out = ( (INT16) (iresultvalue2 -  iresultvalue2_delay) >>AVRBITCOUNT ) + iresultvalue2_
             -delay;
 931          //   iresultvalue2_delay = iresultvalue2_out; 
 932          
 933          
 934          //   //if(iresultcount2++>AVRREADYCOUNT)
 935          //   //{
 936          //   //   iresultcount2 =AVRREADYCOUNT+10;
 937          //   //   iresultvalue2_avr = iresultvalue2_out;
 938          //   //}
 939          //   //else
 940          //   //   iresultvalue2_avr = iresultvalue2;  
 941          //   
 942          //   
 943          //   //iresultvalue2_avr = iresultvalue2;   
 944          //   iresultvalue2_avr = get16_avr2(iresultvalue2);   
 945          
 946          //   sprintf (stemp23,"a2=%u\r\n", iresultvalue2_avr );   
 947          //  
 948          //}      
 949          
 950          void get_LTA_value1(void)
 951          {  
 952   1         UINT8 sbuf1[10]={0};
 953   1         UINT8 sbuf2[10]={0};  
 954   1      
 955   1         //Init_I2C_P13_P14();   
 956   1         
 957   1                  
 958   1         //get LTA0
 959   1         sbuf2[0]=0; sbuf2[1]=0; 
 960   1         i2c_read(0x31, sbuf2, 1);   
 961   1         i2c_read(0x30, sbuf2+1, 1);        
 962   1         
 963   1         iLTA_value1 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 964   1         sprintf (stemp11,"L1 = %u\r\n", iLTA_value1 ); 
 965   1         //iputs0(stemp11); 
 966   1         
 967   1      }
 968          
 969          
 970          void get_resultvalue1(void)
 971          {  
 972   1         UINT8 sbuf1[10]={0};
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 17  

 973   1         UINT8 sbuf2[10]={0};  
 974   1      
 975   1         //Init_I2C_P13_P14();   
 976   1         
 977   1      
 978   1         //get count0
 979   1         sbuf2[0]=0; sbuf2[1]=0; 
 980   1         i2c_read(0x21, sbuf2, 1);   
 981   1         i2c_read(0x20, sbuf2+1, 1);        
 982   1         
 983   1         iresultvalue1 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
 984   1         sprintf (stemp12,"new1 = %u\r\n", iresultvalue1 ); 
 985   1         //iputs0(stemp12);  
 986   1         
 987   1         
 988   1         //iresultvalue1_avr = iresultvalue1;  
 989   1         iresultvalue1_avr = get16_avr(iresultvalue1);     
 990   1      
 991   1         //sprintf (stemp13,"a1=%u\r\n", iresultvalue1_avr );   
 992   1         sprintf (stemp13,"L1,a1=%u,%u\r\n", iLTA_value1,iresultvalue1_avr );   
 993   1        
 994   1      }   
 995          
 996          void get_event1(void)
 997          {  
 998   1         UINT8 sbuf1[10]={0};
 999   1         UINT8 sbuf2[10]={0};  
1000   1         
1001   1      
1002   1         //get count0
1003   1         sbuf2[0]=0; sbuf2[1]=0; 
1004   1         i2c_read(0x11, sbuf2, 1);   
1005   1         i2c_read(0x12, sbuf2+1, 1);        
1006   1      
1007   1         sprintf (stemp15,"ev1,pr1=%bx,%bx\r\n", sbuf2[0],sbuf2[1] );   
1008   1        
1009   1      } 
1010          
1011          
1012          void get_LTA_value2(void)
1013          {  
1014   1         UINT8 sbuf1[10]={0};
1015   1         UINT8 sbuf2[10]={0};  
1016   1      
1017   1         //Init_I2C_P02_P16();      
1018   1      
1019   1         //get LTA0
1020   1         sbuf2[0]=0; sbuf2[1]=0; 
1021   1         i2c_read(0x31, sbuf2, 1);   
1022   1         i2c_read(0x30, sbuf2+1, 1);        
1023   1         
1024   1         iLTA_value2 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
1025   1         sprintf (stemp21,"L2 = %u\r\n", iLTA_value2 ); 
1026   1         //iputs0(stemp21);  
1027   1         
1028   1      }
1029          
1030          
1031          void get_resultvalue2(void)
1032          {  
1033   1         UINT8 sbuf1[10]={0};
1034   1         UINT8 sbuf2[10]={0};  
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 18  

1035   1      
1036   1         //Init_I2C_P02_P16();   
1037   1        
1038   1                  
1039   1         //get count0
1040   1         sbuf2[0]=0; sbuf2[1]=0; 
1041   1         i2c_read(0x21, sbuf2, 1);   
1042   1         i2c_read(0x20, sbuf2+1, 1);        
1043   1         
1044   1         iresultvalue2 = (UINT16)(sbuf2[0] *256 + sbuf2[1]);
1045   1         sprintf (stemp22,"new2 = %u\r\n", iresultvalue2 );   
1046   1         //iputs0(stemp22); 
1047   1       
1048   1            
1049   1         //iresultvalue2_avr = iresultvalue2;   
1050   1         iresultvalue2_avr = get16_avr2(iresultvalue2);   
1051   1      
1052   1         //sprintf (stemp23,"a2=%u\r\n", iresultvalue2_avr );   
1053   1         sprintf (stemp23,"L2,a2=%u,%u\r\n", iLTA_value2,iresultvalue2_avr );   
1054   1        
1055   1      }      
1056          
1057          void get_event2(void)
1058          {  
1059   1         UINT8 sbuf1[10]={0};
1060   1         UINT8 sbuf2[10]={0};  
1061   1         
1062   1      
1063   1         //get count0
1064   1         sbuf2[0]=0; sbuf2[1]=0; 
1065   1         i2c_read(0x11, sbuf2, 1);   
1066   1         i2c_read(0x12, sbuf2+1, 1);   
1067   1       
1068   1         sprintf (stemp25,"ev2,pr2=%bx,%bx\r\n", sbuf2[0],sbuf2[1] );   
1069   1        
1070   1      }
1071          
1072          #define     CFG_READ            0xC0
1073          #define     CFG_ERASE           0xE2
1074          #define     CFG_BYTE_PROGRAM    0xE1 
1075          void Enable_WDT_Reset_Config(void)
1076          {
1077   1         set_IAPEN;
1078   1         set_CFUEN;
1079   1         
1080   1         IAPAL = 0x04;
1081   1         IAPAH = 0x00;
1082   1         IAPFD = 0x0F;
1083   1         IAPCN = CFG_BYTE_PROGRAM;
1084   1         set_IAPGO;  
1085   1         
1086   1         //trigger IAP
1087   1         while((CHPCON&SET_BIT6)==SET_BIT6);          //check IAPFF (CHPCON.6)
1088   1         
1089   1         clr_CFUEN;
1090   1         clr_IAPEN;
1091   1            
1092   1      }
1093          
1094          void gpio_init(void)
1095          {
1096   1         
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 19  

1097   1         //key init   
1098   1         KEY1_L_PIN=0;
1099   1         KEY2_CENTER_PIN=0;
1100   1         KEY3_DOWN_PIN=0;
1101   1         KEY4_R_PIN=0;
1102   1         KEY5_UP_PIN=0;
1103   1         
1104   1         KEY1_L_PUSHPULL_MODE;
1105   1         KEY2_CENTER_PUSHPULL_MODE;
1106   1         KEY3_DOWN_PUSHPULL_MODE;
1107   1         KEY5_UP_PUSHPULL_MODE;
1108   1         KEY4_R_PUSHPULL_MODE;
1109   1         
1110   1         
1111   1         //sensor level init
1112   1         SENSOR_R_PIN=0;
1113   1         SENSOR_L_PIN=0;
1114   1         
1115   1         SENSOR_R_PUSHPULL_MODE;
1116   1         SENSOR_L_PUSHPULL_MODE;
1117   1         
1118   1      }
1119          
1120          
1121          void set_config(void)
1122          {
1123   1         UINT8 sbuf2[10]={0};
1124   1         
1125   1         //set ATI 
1126   1         sbuf2[0]=0; 
1127   1         i2c_read(0x43, sbuf2, 1);    
1128   1      
1129   1         sbuf2[0] &= ~( (1<<0 )| (1<<1) ); 
1130   1         
1131   1         i2c_write(0x43, sbuf2, 1);
1132   1         Timer0_Delay1ms(10);  
1133   1      
1134   1      
1135   1         //set Prox threshold
1136   1         sbuf2[0] = 0x16; 
1137   1         
1138   1         i2c_write(0x60, sbuf2, 1);
1139   1         Timer0_Delay1ms(10);     
1140   1         
1141   1         
1142   1         //set Hysteresis
1143   1         sbuf2[0]=0; 
1144   1         i2c_read(0x80, sbuf2, 1);    
1145   1      
1146   1         sbuf2[0] &= ~( (1<<0 )| (1<<1) ); 
1147   1         sbuf2[0] += 1;    //Hysteresis 1/4
1148   1            
1149   1         i2c_write(0x80, sbuf2, 1);
1150   1         Timer0_Delay1ms(10);     
1151   1         
1152   1         
1153   1      }
1154          
1155          void set_config2(void)
1156          {
1157   1         UINT8 sbuf2[10]={0};
1158   1         
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 20  

1159   1         //set ATI =00
1160   1         sbuf2[0]=0; 
1161   1         i2c_read(0x43, sbuf2, 1);    
1162   1      
1163   1         sbuf2[0] &= ~( (1<<0 )| (1<<1) ); 
1164   1         
1165   1         i2c_write(0x43, sbuf2, 1);
1166   1         Timer0_Delay1ms(10);   
1167   1         
1168   1         
1169   1         //set Prox threshold
1170   1         sbuf2[0] = 0x16; 
1171   1         
1172   1         i2c_write(0x60, sbuf2, 1);
1173   1         Timer0_Delay1ms(10);     
1174   1         
1175   1         
1176   1         //set Hysteresis
1177   1         sbuf2[0]=0; 
1178   1         i2c_read(0x80, sbuf2, 1);    
1179   1      
1180   1         sbuf2[0] &= ~( (1<<0 )| (1<<1) ); 
1181   1         sbuf2[0] += 1;    //Hysteresis 1/4
1182   1            
1183   1         i2c_write(0x80, sbuf2, 1);
1184   1         Timer0_Delay1ms(10);      
1185   1         
1186   1      }
1187          
1188          #define UARTDELAYTIMES   5
1189          void main (void) 
1190          {
1191   1         UINT8 sbuf1[10]={0};
1192   1         UINT8 sbuf2[10]={0};
1193   1         UINT8 stemp[20]={0};  
1194   1          
1195   1         
1196   1         gpio_init();
1197   1         
1198   1         
1199   1         //uart0 init
1200   1         InitialUART0_Timer3(115200);
1201   1         TI = 1;
1202   1         //set_ES;               //For interrupt enable
1203   1         set_EA;  
1204   1      
1205   1         iputs0("start................\r\n");
1206   1            
1207   1         
1208   1         Timer0_Delay1ms(10);   
1209   1      
1210   1         
1211   1         //adc bandgap
1212   1         READ_BANDGAP();   
1213   1         sprintf (stemp,"band vol = %6.2f\r\n",Bandgap_Voltage); 
1214   1         //--iputs0(stemp);      
1215   1      
1216   1      
1217   1         //--- sensor init ---   
1218   1      
1219   1      
1220   1         Timer0_Delay1ms(1000);
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 21  

1221   1         
1222   1         flg_sensor_init =1;
1223   1            
1224   1         //get Bound1    
1225   1        
1226   1         Init_I2C_P13_P14();
1227   1         {
1228   2            set_config(); 
1229   2            get_LTA_value1(); 
1230   2            get_resultvalue1(); 
1231   2         }   
1232   1         
1233   1         if(iLTA_value1 >=RESULT_LOWEST)
1234   1         {
1235   2            //RESULT1_COMEOUT = iLTA_value1 - CENTER_RANGE  + PROX_GAP ;
1236   2            //RESULT1_COMEIN = iLTA_value1 - CENTER_RANGE  - PROX_GAP ;  
1237   2            RESULT1_COMEOUT = iLTA_value1 - PROX_OUT_GAP ;
1238   2            RESULT1_COMEIN = iLTA_value1 - PROX_IN_GAP ;  
1239   2            
1240   2         }
1241   1         else
1242   1         {
1243   2            RESULT1_COMEOUT = 0;
1244   2            RESULT1_COMEIN = 0;   
1245   2            
1246   2            flg_sensor_init =0;
1247   2      
1248   2            iputs0("sensor1 init err\r\n"); 
1249   2            Timer0_Delay1ms(10);      
1250   2         }
1251   1      
1252   1         iputs0(stemp13); Timer0_Delay1ms(10); 
1253   1      
1254   1         //sprintf (stemp,"up1,low1 = %u,%u\r\n",RESULT1_COMEOUT,RESULT1_COMEIN); 
1255   1         //iputs0(stemp);     
1256   1         //Timer0_Delay1ms(10);
1257   1         
1258   1      
1259   1         //get Bound2 
1260   1         Init_I2C_P02_P16();
1261   1         {
1262   2            set_config2();
1263   2            
1264   2            get_LTA_value2(); 
1265   2            get_resultvalue2();
1266   2         }   
1267   1      
1268   1         if(iLTA_value2 >=RESULT_LOWEST)
1269   1         {
1270   2            //RESULT2_COMEOUT = iLTA_value2 - CENTER_RANGE + PROX_GAP ;
1271   2            //RESULT2_COMEIN = iLTA_value2 - CENTER_RANGE - PROX_GAP ;
1272   2            RESULT2_COMEOUT = iLTA_value2 - PROX_OUT_GAP ;
1273   2            RESULT2_COMEIN = iLTA_value2 - PROX_IN_GAP ;
1274   2         }
1275   1         else
1276   1         {
1277   2            RESULT2_COMEOUT = 0;
1278   2            RESULT2_COMEIN = 0;   
1279   2            
1280   2            flg_sensor_init =0;
1281   2      
1282   2            iputs0("sensor2 init err\r\n"); 
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 22  

1283   2            Timer0_Delay1ms(10);      
1284   2         }   
1285   1         iputs0(stemp23); Timer0_Delay1ms(10); 
1286   1      
1287   1         //sprintf (stemp,"up2,low2 = %u,%u\r\n",RESULT2_COMEOUT, RESULT2_COMEIN); 
1288   1         //iputs0(stemp); 
1289   1         //Timer0_Delay1ms(10);    
1290   1         
1291   1         iputs0("\r\n"); Timer0_Delay1ms(2); 
1292   1      
1293   1            
1294   1         //timer1 init
1295   1         timer1_init();     
1296   1         
1297   1         //WDT init
1298   1         Enable_WDT_Reset_Config();
1299   1         set_WDTR;                        
1300   1         set_WDCLR;     
1301   1      
1302   1      
1303   1         //P17_PushPull_Mode;  //--test
1304   1      
1305   1      
1306   1         while(1)
1307   1         {     
1308   2      
1309   2            //--static UINT32 imaincount =0 ; 
1310   2            
1311   2            set_WDCLR;      
1312   2      
1313   2      //iadc =   Bandgap_Voltage * AIN_value  / BAND_value ;  //mv        
1314   2      //iadcvalue = (UINT16)iadc;      
1315   2            
1316   2            
1317   2            if(flg_channel==1)
1318   2            {
1319   3               flg_channel=0;       
1320   3               
1321   3               //if(iadccount++>AVRREADYCOUNT)
1322   3               //{
1323   3               //   iadccount =AVRREADYCOUNT+10;
1324   3               //   iadcvalue_avr = iadcvalue_out;            
1325   3               //}
1326   3               //else         
1327   3               //   iadcvalue_avr = iadcvalue;
1328   3               iadcvalue_avr = iadcvalue;
1329   3       
1330   3               
1331   3               iadc_key = (UINT16)((double)BAND_value / BAND_3300 * iadcvalue_avr);
1332   3               
1333   3               //sprintf( sadctemp1, "BAND: %u\r\n", BAND_value); 
1334   3               sprintf( sadctemp1, "adc: %u\r\n", iadc_key); 
1335   3               sprintf( sadctemp2, "BAND: %u, iadc: %u\r\n", BAND_value,iadcvalue_avr);          
1336   3               
1337   3               
1338   3               if(iadc_key <= ADC_VOL_NC )
1339   3               {
1340   4                  Timer0_Delay1ms(10); 
1341   4      
1342   4                  if(iadc_key <= ADC_VOL_NC )
1343   4                  {
1344   5                     //--if(KEY0_NC_PIN==0) {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("no key\r\n"); Timer0
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 23  

             -_Delay1ms(2); }               
1345   5                     sprintf( sadcstate, "no key\r\n"); 
1346   5                     
1347   5                     KEY0_NC_PIN = 1;
1348   5                     KEY1_L_PIN = 0;
1349   5                     KEY2_CENTER_PIN = 0;
1350   5                     KEY3_DOWN_PIN = 0;
1351   5                     KEY4_R_PIN = 0;
1352   5                     KEY5_UP_PIN = 0;
1353   5                     
1354   5                  }               
1355   4               }
1356   3               else if(iadc_key >= ADC_VOL_NC2 )
1357   3               {
1358   4                  Timer0_Delay1ms(10); 
1359   4      
1360   4                  if(iadc_key >= ADC_VOL_NC2 )
1361   4                  {
1362   5                     //--if(KEY0_NC_PIN==0) {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("no key2\r\n"); Timer
             -0_Delay1ms(2); }
1363   5                     sprintf( sadcstate, "no key2\r\n");
1364   5                     
1365   5                     KEY0_NC_PIN = 1;
1366   5                     KEY1_L_PIN = 0;
1367   5                     KEY2_CENTER_PIN = 0;
1368   5                     KEY3_DOWN_PIN = 0;
1369   5                     KEY4_R_PIN = 0;
1370   5                     KEY5_UP_PIN = 0;
1371   5                     
1372   5                  }               
1373   4               }         
1374   3               
1375   3               else if (iadc_key >= ADC_VOL_R )
1376   3               {
1377   4                  Timer0_Delay1ms(10); 
1378   4      
1379   4                  if(iadc_key >= ADC_VOL_R )
1380   4                  {
1381   5                     if(KEY4_R_PIN==0)  {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("right key\r\n"); Timer0_
             -Delay1ms(2); }
1382   5                     sprintf( sadcstate, "right key\r\n");
1383   5                  
1384   5                     KEY0_NC_PIN = 0;
1385   5                     KEY1_L_PIN = 0;
1386   5                     KEY2_CENTER_PIN = 0;
1387   5                     KEY3_DOWN_PIN = 0;
1388   5                     KEY5_UP_PIN = 0;
1389   5                     KEY4_R_PIN = 1;  
1390   5                     
1391   5                  }               
1392   4               }
1393   3      
1394   3               else if (iadc_key >= ADC_VOL_DOWN )
1395   3               {
1396   4                  Timer0_Delay1ms(10); 
1397   4      
1398   4                  if(iadc_key >= ADC_VOL_DOWN )
1399   4                  {
1400   5                     if(KEY3_DOWN_PIN==0)  {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("down key\r\n"); Timer
             -0_Delay1ms(2); }
1401   5                     sprintf( sadcstate, "down key\r\n");
1402   5      
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 24  

1403   5                     KEY0_NC_PIN = 0;
1404   5                     KEY1_L_PIN = 0;
1405   5                     KEY2_CENTER_PIN = 0;
1406   5                     KEY3_DOWN_PIN = 1;
1407   5                     KEY4_R_PIN = 0;  
1408   5                     KEY5_UP_PIN = 0;
1409   5                     
1410   5                  }               
1411   4               }     
1412   3               else if(iadc_key >= ADC_VOL_L )
1413   3               {
1414   4                  Timer0_Delay1ms(10); 
1415   4      
1416   4                  if(iadc_key >= ADC_VOL_L )
1417   4                  {
1418   5                     if(KEY1_L_PIN==0) {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("left key\r\n"); Timer0_De
             -lay1ms(2); }
1419   5                     sprintf( sadcstate, "left key\r\n");
1420   5                     
1421   5                     KEY0_NC_PIN = 0;
1422   5                     KEY1_L_PIN = 1;
1423   5                     KEY2_CENTER_PIN = 0;
1424   5                     KEY3_DOWN_PIN = 0;
1425   5                     KEY4_R_PIN = 0;  
1426   5                     KEY5_UP_PIN = 0;
1427   5                     
1428   5                  }               
1429   4               } 
1430   3               else if (iadc_key >= ADC_VOL_CENTER )
1431   3               {
1432   4                  Timer0_Delay1ms(10);  
1433   4      
1434   4                  if(iadc_key >= ADC_VOL_CENTER )
1435   4                  {
1436   5                     if(KEY2_CENTER_PIN==0)  { iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("center key\r\n"); 
             -Timer0_Delay1ms(2);}
1437   5                     sprintf( sadcstate, "center key\r\n");
1438   5      
1439   5                     KEY0_NC_PIN = 0;
1440   5                     KEY1_L_PIN = 0;
1441   5                     KEY2_CENTER_PIN = 1;
1442   5                     KEY3_DOWN_PIN = 0;
1443   5                     KEY4_R_PIN = 0;   
1444   5                     KEY5_UP_PIN = 0;
1445   5                     
1446   5                  }               
1447   4               }         
1448   3               else if (iadc_key >= ADC_VOL_UP )
1449   3               {
1450   4                  Timer0_Delay1ms(10); 
1451   4      
1452   4                  if(iadc_key >= ADC_VOL_UP )
1453   4                  {
1454   5                     if(KEY5_UP_PIN==0)  {iputs0(sadctemp1); Timer0_Delay1ms(2); iputs0("up key\r\n"); Timer0_De
             -lay1ms(2); }
1455   5                     sprintf( sadcstate, "up key\r\n");
1456   5      
1457   5                     //KEY0_NC_PIN = 0;
1458   5                     KEY1_L_PIN = 0;
1459   5                     KEY2_CENTER_PIN = 0;
1460   5                     KEY3_DOWN_PIN = 0;
1461   5                     KEY4_R_PIN = 0;   
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 25  

1462   5                     KEY5_UP_PIN = 1;
1463   5                     
1464   5                  }               
1465   4               }         
1466   3                
1467   3            }    
1468   2      
1469   2            
1470   2            //get resultvalue
1471   2            if(itimer1_count>=200)
1472   2            {
1473   3               itimer1_count=0;   
1474   3      
1475   3               iltascan++;          
1476   3               
1477   3               if (iltascan>=50)
1478   3               {
1479   4      
1480   4                  iltascan=0;
1481   4                  
1482   4                  //get LTA value1          
1483   4                  Init_I2C_P13_P14();
1484   4                  {
1485   5                     get_LTA_value1(); 
1486   5                  }
1487   4      
1488   4                  //get LTA value2 
1489   4                  Init_I2C_P02_P16();
1490   4                  {
1491   5                     get_LTA_value2(); 
1492   5                  }  
1493   4               }
1494   3               else
1495   3               {
1496   4                  
1497   4                  //get the result value1          
1498   4                  Init_I2C_P13_P14();
1499   4                  {
1500   5                     get_resultvalue1(); 
1501   5                     get_event1(); 
1502   5                  }
1503   4      
1504   4                  //get the result value2 
1505   4                  Init_I2C_P02_P16();
1506   4                  {
1507   5                     get_resultvalue2();
1508   5                     get_event2(); 
1509   5                  }    
1510   4                  
1511   4      //            if( (flg_sensor_init==1) && (iresultvalue1>0) && (iresultvalue2>0) )
1512   4      //            {
1513   4      
1514   4      //               //result value1 check
1515   4      //               if (iresultvalue1_avr >= RESULT1_COMEOUT)  
1516   4      //                  {SENSOR_R_PIN=0;   }
1517   4      //                  
1518   4      //               //else if ( (iresultvalue1_avr <= RESULT1_COMEIN) && (oldvalue1[1] <= RESULT1_COMEIN) && 
             -(oldvalue1[2] <= RESULT1_COMEIN) )  
1519   4      //               else if (iresultvalue1_avr <= RESULT1_COMEIN)    
1520   4      //                  {SENSOR_R_PIN=1; }
1521   4      //                  //{SENSOR_R_PIN=1; iputs0(stemp13); iputs0("prox1 in\r\n"); }
1522   4      //                  
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 26  

1523   4      
1524   4      //               //result value2 check
1525   4      //               if (iresultvalue2_avr >= RESULT2_COMEOUT)
1526   4      //                  {SENSOR_L_PIN=0;  }
1527   4      //                  
1528   4      //               //else if ( (iresultvalue2_avr <= RESULT2_COMEIN) && (oldvalue2[1] <= RESULT2_COMEIN) && 
             -(oldvalue2[2] <= RESULT2_COMEIN) )  
1529   4      //               else if (iresultvalue2_avr <= RESULT2_COMEIN)
1530   4      //                  {SENSOR_L_PIN=1; }         
1531   4      //                   //{SENSOR_L_PIN=1; iputs0(stemp23); iputs0("prox2 in\r\n");}    
1532   4      //               
1533   4      //            }
1534   4      
1535   4               }            
1536   3                        
1537   3            }       
1538   2      
1539   2            
1540   2            if( (itimer1_count2>=2000)  && (itimer1_count>=20) )
1541   2            {
1542   3               itimer1_count2=0;           
1543   3                
1544   3      //         ////adc
1545   3      //         //iputs0(sadctemp1); 
1546   3      //         //Timer0_Delay1ms(UARTDELAYTIMES); 
1547   3      
1548   3      //         //iputs0(sadctemp2); 
1549   3      //         //Timer0_Delay1ms(UARTDELAYTIMES); 
1550   3      
1551   3      //         //iputs0(sadcstate); 
1552   3      //         //Timer0_Delay1ms(UARTDELAYTIMES); 
1553   3      
1554   3      //         //iputs0 ("\r\n" );       
1555   3      //         //Timer0_Delay1ms(UARTDELAYTIMES);  
1556   3      
1557   3                        
1558   3               ////i2c
1559   3               //iputs0(stemp11); 
1560   3               //Timer0_Delay1ms(UARTDELAYTIMES); 
1561   3      
1562   3               //iputs0(stemp12); 
1563   3               //Timer0_Delay1ms(UARTDELAYTIMES); 
1564   3               
1565   3               iputs0(stemp13); 
1566   3               Timer0_Delay1ms(UARTDELAYTIMES);  
1567   3               
1568   3               iputs0(stemp15); 
1569   3               Timer0_Delay1ms(UARTDELAYTIMES);  
1570   3               
1571   3               
1572   3               //iputs0(stemp21); 
1573   3               //Timer0_Delay1ms(UARTDELAYTIMES); 
1574   3      
1575   3               //iputs0(stemp22); 
1576   3               //Timer0_Delay1ms(UARTDELAYTIMES); 
1577   3               
1578   3               iputs0(stemp23); 
1579   3               Timer0_Delay1ms(UARTDELAYTIMES);          
1580   3               
1581   3               iputs0(stemp25); 
1582   3               Timer0_Delay1ms(UARTDELAYTIMES);          
1583   3               
C51 COMPILER V9.56.0.0   MAIN                                                              05/20/2019 12:38:20 PAGE 27  

1584   3               iputs0 ("\r\n" );       
1585   3               Timer0_Delay1ms(2);
1586   3            }  
1587   2            
1588   2           
1589   2      //      if( (itimer1_count2>=2000)  && (itimer1_count>=20) )
1590   2      //      {
1591   2      //         itimer1_count2=0;  
1592   2      //                
1593   2      //         iputs0(stemp13); 
1594   2      //         Timer0_Delay1ms(UARTDELAYTIMES);  
1595   2      
1596   2      //         iputs0(stemp23); 
1597   2      //         Timer0_Delay1ms(UARTDELAYTIMES);      
1598   2      
1599   2      //         iputs0 ("\r\n" );       
1600   2      //         Timer0_Delay1ms(2);         
1601   2      //      }    
1602   2            
1603   2         }   
1604   1            
1605   1      }
1606          
1607          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5232    ----
   CONSTANT SIZE    =    542    ----
   XDATA SIZE       =    336     233
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
